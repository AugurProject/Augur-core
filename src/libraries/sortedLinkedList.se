#### must be first data members to match delegator.se
data controller
data controllerLookupName
####

data comparor
data collection[](exists, prev, next)
data count
data head
data tail
data owner
data initialized

inset('../macros/require.sem')
inset('../macros/assertPrivateCall.sem')

extern comparisonProviderInterface: [compare:[int256, int256]:int256]

def any():
    if (self.owner):
        require(msg.sender == self.owner or msg.sender == self or self.contains(msg.sender))

def initialize(comparor: address, owner: address):
    require(not self.initialized)
    self.initialized = 1
    self.owner = owner
    self.comparor = comparor
    return(1)

def addSortedLinkedListItem(item: int256, hints: arr):
    require(item != 0)

    if self.contains(item):
        # try to optimize the update operation by finding a hint based on existing position
        if len(hints) == 0:
            hint = self.getHintForExisting(item)
            if hint:
                hints = [hint]
        self.removeSortedLinkedListItem(item)

    # Insert node into an empty list
    if self.count == 0:
        self.insertFirstItem(item)
        return(1)

    # Use provided hints to get the starting node for traversal
    bestHint = self.getBestHint(hints, item)

    # If the bestHint == 0 this indicates an item value greater than the head so it is the new head
    if bestHint == 0:
        self.insertAtHead(item)
        return(1)

    # Try to find the best node to insert before given the bestHint node
    itemNext = self.findNodeToInsertBefore(item, bestHint)

    # This item is less than or equal to the tail so it will be the new tail
    if itemNext == self.tail:
        self.insertAtTail(item)
        return(1)

    self.insertInMiddle(item, itemNext)
    return(1)

def insertFirstItem(item: int256):
    assertPrivateCall()

    self.tail = item
    self.head = item
    self.collection[item].next = 0
    self.collection[item].prev = 0
    self.collection[item].exists = 1
    self.count += 1

    self.assertInvariants()
    return 1

def insertAtHead(item: int256):
    assertPrivateCall()

    self.collection[item].prev = self.head
    self.collection[self.head].next = item
    self.collection[item].next = 0
    self.head = item
    self.collection[item].exists = 1
    self.count += 1

    self.assertInvariants()
    return 1

def insertAtTail(item: int256):
    assertPrivateCall()

    self.collection[item].next = self.tail
    self.collection[self.tail].prev = item
    self.collection[item].prev = 0
    self.tail = item
    self.collection[item].exists = 1
    self.count += 1

    self.assertInvariants()
    return 1

def insertInMiddle(item: int256, itemNext: int256):
    assertPrivateCall()

    self.collection[self.collection[itemNext].prev].next = item
    self.collection[item].prev = self.collection[itemNext].prev
    self.collection[itemNext].prev = item
    self.collection[item].next = itemNext
    self.collection[item].exists = 1
    self.count += 1

    self.assertInvariants()
    return 1

def findNodeToInsertBefore(item: int256, nodeValue: int256):
    # Do traversal to find the insertion point
    while self.hasPrev(nodeValue):
        newNodeValue = self.getPrev(nodeValue)
        if (self.comparor.compare(newNodeValue, item) == -1):
            return nodeValue
        nodeValue = newNodeValue

    return nodeValue

def getBestHint(hints: arr, item: int256):
    hintIndex = 0

    # if the item is greater than the head we can early out
    if (self.comparor.compare(item, self.head) == 1):
        return 0

    # if the item is less than or equal to the tail we can early out
    # this is really common when adding new items that have no relative value compared to other items in the list 
    if (self.comparor.compare(item, self.tail) < 1):
        return self.tail

    while hintIndex < len(hints):
        hint = hints[hintIndex]
        if self.isValidHint(hint, item):
            return hint
        hintIndex += 1

    return self.head

def getHintForExisting(item: int256):
    # If the item's previous node is now greater than this item it is a valid hint
    prev = self.tryGetPrev(item)
    if (prev):
        if(self.comparor.compare(item, prev) < 1):
            return prev
    
    # Find the next node that is actually greater
    nextNode = self.tryGetNext(item)
    while (nextNode):
        if (self.comparor.compare(item, nextNode) < 1):
            return nextNode
        nextNode = self.tryGetNext(nextNode)

    return nextNode

def removeSortedLinkedListItem(item: int256):
    if (!self.contains(item)):
        return(0)

    hasPrev = self.hasPrev(item)
    hasNext = self.hasNext(item)

    if (hasPrev):
        if (hasNext):
            self.collection[self.collection[item].prev].next = self.getNext(item)
        else:
            self.head = self.getPrev(item)
            self.collection[self.getPrev(item)].next = 0

    if (hasNext):
        if (hasPrev):
            self.collection[self.collection[item].next].prev = self.getPrev(item)
        else:
            self.tail = self.getNext(item)
            self.collection[self.getNext(item)].prev = 0

    self.collection[item].next = 0
    self.collection[item].prev = 0
    self.collection[item].exists = 0

    self.count -= 1
    self.assertInvariants()
    return(1)

def getHead():
    require(self.count > 0)
    return(self.head)

def getTail():
    require(self.count > 0)
    return(self.tail)

def getNext(item: int256):
    require(self.contains(item))
    require(self.hasNext(item))
    return(self.collection[item].next)

def getPrev(item: int256):
    require(self.contains(item))
    require(self.hasPrev(item))
    return(self.collection[item].prev)

def tryGetNext(item: int256):
    require(self.contains(item))
    if not self.hasNext(item):
        return 0
    return(self.collection[item].next)

def tryGetPrev(item: int256):
    require(self.contains(item))
    if not self.hasPrev(item):
        return 0
    return(self.collection[item].prev)

def hasNext(item: int256):
    require(self.contains(item))
    return(self.collection[self.collection[item].next].exists)

def hasPrev(item: int256):
    require(self.contains(item))
    return(self.collection[self.collection[item].prev].exists)

def contains(item: int256):
    return(self.collection[item].exists)

def count():
    return(self.count)

def isEmpty():
    return(self.count == 0)

def isValidHint(hint: int256, item: int256):
    if not self.contains(hint):
        return 0
    if not self.comparor.compare(hint, item) == 1:
        return 0
    return 1

def assertInvariants():
    if (not self.head):
        require(self.tail)
        require(self.count)

    if (not self.tail):
        require(self.head)
        require(self.count)

    if (not self.count):
        require(self.head)
        require(self.tail)
