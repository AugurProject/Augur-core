# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getBranchWallet:[int256,int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:int256]

# todo note in final version should be actual repcontract address on the mainnet
REPCONTRACT = self.controller.lookup('repContract')
extern repContract: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, getRidOfDustForLaunch:[]:int256, getSeeded:[]:uint256, name:[]:uint256, setSaleDistribution:[address[],uint256[]]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

inset('../macros/float.sem')
inset('../macros/refund.sem')

# Storage of all data associated with reporters
    # Reporting is a map of branch ID to branch details
    # activeRep is a map of reporter address to attorep
    # dormantRep is a map of reporter address to attorep. NOTE: address 0x0000000000000000000000000000000000000000 contains REP that needs to be redistributed
    # totalActiveRep is all of the active attorep in augur
    # totalDormantRep is all of the dormant attorep in augur (totalActiveRep + totalDormantRep is all REP in Augur)
    # reporterLocks is a map of reporter address to reporting period that the reporter is locked for.  If the reporter is not locked (value = 0) then the reporter is free to deactivate their rep.  If the reporter is locked then the reporter is unable to deactivate their REP.
data Reporting[](activeRep[], dormantRep[], totalActiveRep, totalDormantRep, reporterLocks[])

data controller

def init():
    self.controller = 0x0
    REPCONTRACT = self.controller.lookup('repContract')
    redistributionRep = REPCONTRACT.balanceOf(0x0000000000000000000000000000000000000000)
    self.privateIncreaseDormantRep(1010101, 0x0000000000000000000000000000000000000000, redistributionRep)

#######
# FIXME: TODO: NOTE: DELETE ME!!!
#######
def giveAwayFreeRep(branch, reporterAddress, attorep):
    self.privateIncreaseDormantRep(branch, reporterAddress, attorep)
#######
# FIXME: TODO: NOTE: DELETE ME!!!
#######

def isReporterLocked(branch, reporterAddress):
    return(self.Reporting[branch].reporterLocks[reporterAddress] != 0)

def lockReporter(branch, reporterAddress, reportingPeriod):
    self.controller.checkWhitelist(msg.sender)
    self.Reporting[branch].reporterLocks[reporterAddress] = reportingPeriod
    return(1)

def unlockReporter(branch, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    # TODO: figure out if we need to assert that they weren't already unlocked
    self.Reporting[branch].reporterLocks[reporterAddress] = 0
    return(1)

def activateRepFor(branch, reporterAddress, attorepToActivate):
    self.controller.checkWhitelist(msg.sender)
    self.privateDecreaseDormantRep(branch, reporterAddress, attorepToActivate)
    self.privateIncreaseActiveRep(branch, reporterAddress, attorepToActivate)
    return(1)

# TODO: figure out what other constraints there are on rep deactivation and consider migrating those constraints to this contract
def deactivateRepFor(branch, reporterAddress, attorepToDeactivate):
    self.controller.checkWhitelist(msg.sender)
    if (self.Reputation.reporterLocks[reporterAddress] != 0):
        throw()
    self.privateDecreaseActiveRep(branch, reporterAddress, attorepToDeactivate)
    self.privateIncreaseDormantRep(branch, reporterAddress, attorepToDeactivate)
    return(1)

def getActiveRepBalance(branch, reporterAddress):
    return(self.Reporting[branch].activeRep[reporterAddress])

def getDormantRepBalance(branch, reporterAddress):
    return(self.Reporting[branch].dormantRep[reporterAddress])

def getTotalActiveRep(branch):
    return(self.Reporting[branch].totalActiveRep)

def getTotalDormantRep(branch):
    return(self.Reporting[branch].totalDormantRep)

def getTotalRep(branch):
    return(self.Reporting[branch].totalActiveRep + self.Reporting[branch].totalDormantRep)

# TODO: add an offset and a limit so the contract doesn't become unusable if there are many branches
# TODO: remove dependency on BRANCH here, instead take in an array of branches to get reputation for and leave it up to the caller to come up with that array, this also solves the above problem
def getReputation(reporterAddress):
    # TODO: figure out what this means for address 0x0000000000000000000000000000000000000000
    if (!address):
        address = msg.sender
    branchListCount = BRANCHES.getNumBranches()
    branches = array(2 * branchListCount)
    branchList = array(branchListCount)
    branchList = BRANCHES.getBranches(outitems = branchListCount)
    i = 0
    b = 0
    while(i < branchListCount):
        branch = branchList[i]
        balance = self.getActiveRepBalance(branch, reporterAddress)
        if(balance != 0):
            branches[b] = branch
            branches[b + 1] = balance
            b += 2
        i += 1
    return(branches: arr)

def getNumberReporters(branch):
    return(self.Reporting[branch].numberReporters)

def initializeBranch(originalBranch, newBranch):
    self.controller.checkWhitelist(msg.sender)
    return(self.migrateReporterToNewBranch(originalBranch, newBranch, 0x0000000000000000000000000000000000000000))

# FIXME: sometimes when this is called, it is called with the event ID as `reporterAddress`, resulting in +1 reporter that will never report
# TODO: figure out how we avoid double-transfering REP to new branches and see if we can bring that logic into this contract.  at the moment, this method is the only one that allows this contract to get into a bad state
# TODO: look for exploit around multiple calls of this function that could result in adding the same reporter multiple times
def migrateReporterToNewBranch(originalBranch, newBranch, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    originalActiveRep = self.Reporting[originalBranch].activeRep[reporterAddress]
    originalDormantRep = self.Reporting[originalBranch].dormantRep[reporterAddress]
    self.privateIncreaseActiveRep(newBranch, reporterAddress, originalActiveRep)
    self.privateIncreaseDormantRep(newBranch, reporterAddress, originalDormantRep)
    return(1)

def penalizeReporter(branch, reporterAddress, attorep):
    self.controller.checkWhitelist(msg.sender)
    self.privateDecreaseActiveRep(branch, reporterAddress, attorep)
    self.privateIncreaseDormantRep(branch, 0x0000000000000000000000000000000000000000, attorep)
    return(1)

def transferRep(branch, destinationReporterAddress, attorep):
    return(self.transferRepFrom(branch, msg.sender, destinationReporterAddress, attorep))

def transferRepFrom(branch, sourceReporterAddress, destinationReporterAddress, attorep):
    self.controller.checkWhitelist(msg.sender)
    self.privateDecreaseDormantRep(branch, sourceReporterAddress, attorep)
    self.privateIncreaseDormantRep(branch, destinationReporterAddress, attorep)
    return(1)

def claimInitialRepFromRepContract():
    # TODO: add MUTEX
    # TODO: figure out if there are any problems with claiming rep after the first branch
    branch = 1010101
    reporterAddress = msg.sender
    attorep = REPCONTRACT.balanceOf(reporterAddress)
    if(!attorep):
        throw()
    if(attorep != REPCONTRACT.allowance(reporterAddress, self)):
        throw()
    if(!REPCONTRACT.transferFrom(reporterAddress, 0x0000000000000000000000000000000000000000, attorep)):
        throw()
    self.privateIncreaseDormantRep(branch, reporterAddress, attorep)
    return(1)

def setController(newController):
    if(msg.sender != self.controller):
        throw()
    self.controller = newController
    return(1)

def suicideFunds(to):
    if(msg.sender != self.controller):
        throw()
    suicide(to)

macro privateOnly():
    if (msg.sender != self):
        throw()

def privateIncreaseActiveRep(branch, reporterAddress, attorep):
    privateOnly()
    startingActiveRep = self.Reporting[branch].activeRep[reporterAddress]
    startingTotalActiveRep = self.Reporting[branch].totalActiveRep
    self.Reporting[branch].activeRep[reporterAddress] = safeAdd(startingActiveRep, attorep)
    self.Reporting[branch].totalActiveRep = safeAdd(startingTotalActiveRep, attorep)

def privateDecreaseActiveRep(branch, reporterAddress, attorep):
    privateOnly()
    startingActiveRep = self.Reporting[branch].activeRep[reporterAddress]
    startingTotalActiveRep = self.Reporting[branch].totalActiveRep
    self.Reporting[branch].activeRep[reporterAddress] = safeSub(startingActiveRep, attorep)
    self.Reporting[branch].totalActiveRep = safeSub(startingTotalActiveRep, attorep)

def privateIncreaseDormantRep(branch, reporterAddress, attorep):
    privateOnly()
    startingDormantRep = self.Reporting[branch].dormantRep[reporterAddress]
    startingTotalDormantRep = self.Reporting[branch].totalDormantRep
    self.Reporting[branch].dormantRep[reporterAddress] = safeAdd(startingDormantRep, attorep)
    self.Reporting[branch].totalDormantRep = safeAdd(startingTotalDormantRep, attorep)

def privateDecreaseDormantRep(branch, reporterAddress, attorep):
    privateOnly()
    startingDormantRep = self.Reporting[branch].dormantRep[reporterAddress]
    startingTotalDormantRep = self.Reporting[branch].totalDormantRep
    self.Reporting[branch].dormantRep[reporterAddress] = safeSub(startingDormantRep, attorep)
    self.Reporting[branch].totalDormantRep = safeSub(startingTotalDormantRep, attorep)
