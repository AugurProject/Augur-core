{
    "branches": {
        "address": "0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "# CurrentVotePeriod is the current index in eventsExpDates", 
            "# Branches' index is the hash of the branch (aka branchID)", 
            "# currentVotePeriod is a nonce that tells us which bucket of events up to be", 
            "# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)", 
            "# period parameter for reporting", 
            "# currentExpPeriod = (block.number / self.Branches[branch].periodLength)", 
            "# currentExpPeriod - 1 is what's up for reporting at any given time", 
            "# should add a min initial liquidity property, for non pm branches it'd be low and .5*minInitialLiquidity is == fee for event", 
            "# could also add an event fee parameter", 
            "data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod)", 
            "", 
            "# first param is the branch, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "data branchList[]", 
            "", 
            "data branchListCount", 
            "", 
            "def init():", 
            "    self.Branches[1010101].currentVotePeriod = (block.number / 100) - 1", 
            "    self.Branches[1010101].periodLength = 100", 
            "    self.Branches[1010101].minTradingFee = 2^54", 
            "    self.branchListCount = 1", 
            "    self.branchList[0] = 1010101", 
            "", 
            "# call once after uploading (externed method not allowed in init)", 
            "def initDefaultBranch():", 
            "    return(CASH.initiateOwner(1010101))", 
            "", 
            "def getOracleOnly(branch):", 
            "\treturn(self.Branches[branch].oracleOnly)", 
            "", 
            "def getVotePeriod(branch):", 
            "\treturn(self.Branches[branch].currentVotePeriod)", 
            "", 
            "def getPeriodLength(branch):", 
            "\treturn(self.Branches[branch].periodLength)", 
            "", 
            "# branch cash balance at start of period", 
            "def setInitialBalance(branch, period, balance):", 
            "\tself.Branches[branch].balance[period] = balance", 
            "\treturn(balance)", 
            "", 
            "def getInitialBalance(branch, period):", 
            "\treturn(self.Branches[branch].balance[period])", 
            "", 
            "# @return all markets in a branch", 
            "def getMarketsInBranch(branch):", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "# @return all markets in a branch", 
            "def getSomeMarketsInBranch(branch, initial, last):", 
            "    numMarkets = last - initial", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[initial+i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getNumMarketsBranch(branch):", 
            "\treturn(self.Branches[branch].numMarkets)", 
            "", 
            "def getMinTradingFee(branch):", 
            "\treturn(self.Branches[branch].minTradingFee)", 
            "", 
            "# @return all branches", 
            "def getBranches():", 
            "    b = 0", 
            "    numBranches = self.branchListCount", 
            "    branches = array(numBranches)", 
            "    while b < numBranches:", 
            "        branches[b] = self.branchList[b]", 
            "        b += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumBranches():", 
            "\treturn(self.branchListCount)", 
            "", 
            "def getBranch(branchNumber):", 
            "\treturn(self.branchList[branchNumber])", 
            "", 
            "def getCreationDate(ID):", 
            "\treturn(self.Branches[ID].creationDate)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Branches[ID].periodLength==0):", 
            "\t\tself.Branches[ID].currentVotePeriod = currentVotePeriod", 
            "\t\tself.Branches[ID].periodLength = periodLength", 
            "\t\tself.Branches[ID].minTradingFee = minTradingFee", 
            "\t\tself.branchList[self.branchListCount] = ID", 
            "\t\tself.branchListCount += 1", 
            "\t\tself.Branches[ID].creationDate = block.number", 
            "\t\tself.Branches[ID].parentPeriod = parentPeriod", 
            "\t\tself.Branches[ID].oracleOnly = oracleOnly", 
            "\t\tCASH.initiateOwner(ID)", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def getParentPeriod(branch):", 
            "    return(self.Branches[branch].parentPeriod)", 
            "", 
            "def incrementPeriod(branch):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Branches[branch].currentVotePeriod += 1", 
            "\treturn(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addMarketToBranch(branch, market):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tnumMarkets = self.Branches[branch].numMarkets", 
            "\tself.Branches[branch].markets[numMarkets] = market", 
            "\tself.Branches[branch].numMarkets += 1", 
            "\treturn(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarketToBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branchNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationDate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getNumBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarketsBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getOracleOnly(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParentPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initial", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last", 
                        "type": "int256"
                    }
                ], 
                "name": "getSomeMarketsInBranch(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "initDefaultBranch()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parentPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeBranch(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialBalance(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]"
    }, 
    "buy&sellShares": {
        "address": "0xd15a6cfc462ae76b9ec590cab8b34bfa8e1302d7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "event updatePrice(user:indexed, market:indexed, outcome:indexed, price, cost)", 
            "", 
            "# market, reporter", 
            "data trades[][](hash, block)", 
            "", 
            "def commitTrade(market, hash):", 
            "    self.trades[market][tx.origin].hash = hash", 
            "    self.trades[market][tx.origin].block = block.number", 
            "    return(1)", 
            "", 
            "def makeMarketHash(market, outcome, amount, limit):", 
            "    buyInfo = array(4)", 
            "    buyInfo[0] = market", 
            "    buyInfo[1] = outcome", 
            "    buyInfo[2] = amount", 
            "    buyInfo[3] = limit", 
            "    buyHash = sha256(buyInfo, items=4)", 
            "    return(buyHash)", 
            "", 
            "# amount of shares should be fixed point", 
            "# @return return price + fee to buy shares", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or trading closed", 
            "    # -2: entered a -amt of shares", 
            "    # -3: not enough money / limit order too low", 
            "    # -4: invalid outcome", 
            "    # -5: bad commitment or no commitment", 
            "    # -6: oracle only branch, no trading", 
            "def buyShares(branch, market, outcome, amount, limit):", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-6)", 
            "", 
            "    buyInfo = array(4)", 
            "    buyInfo[0] = market", 
            "    buyInfo[1] = outcome", 
            "    buyInfo[2] = amount", 
            "    buyInfo[3] = limit", 
            "    buyHash = sha256(buyInfo, items=4)", 
            "    if(self.trades[market][tx.origin].hash != buyHash || block.number == self.trades[market][tx.origin].block):", 
            "        return(-5)", 
            "    self.trades[market][tx.origin].hash = 0", 
            "    # make it so trader has locked in fee from buy, so if they sell and they bought when fee was low, they can sell with that low fee as opposed to a high one", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):", 
            "        return(-4)", 
            "    n = 0", 
            "    #if event gets pushed back people can still buy / sell", 
            "    pushedBack = 0", 
            "    while n < numEvents:", 
            "        #if(EVENTS.getPushedBack(events[n])==0):", 
            "        if(1):", 
            "            n += 1", 
            "        # pushed back and not resolved", 
            "        elif(EVENTS.getOutcome(events[n])==0):", 
            "            pushedBack = 1", 
            "            n = numEvents", 
            "        else:", 
            "          n += 1", 
            "    ### TODO: check for .99 market here", 
            "    if (outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if newCost <= oldCost:", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(0)", 
            "    price = (newCost - oldCost)", 
            "", 
            "    if(CASH.balance(tx.origin) < price*(MARKETS.getTradingFee(market) + 2^64)/2^64 or (limit!=0 and (price*2^64/amount)>limit)):", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(-3)", 
            "", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "", 
            "    # if participant doesn't exist in market, add them", 
            "    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, tx.origin)", 
            "", 
            "    MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, amount)", 
            "    # send shares of the event to user address", 
            "    # if user doesn't have enough money, revert", 
            "    # send money from user acc. to market address/account", 
            "    # cost for shares", 
            "    CASH.send(market, price)", 
            "    # half of fees to market creator", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    CASH.send(INFO.getCreator(market), fee/2)", 
            "    # other half go to branch", 
            "    CASH.send(branch, fee/2)", 
            "    # log new price & avg price paid/share", 
            "    log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), -(price+fee)*2^64/amount)", 
            "    return(1)", 
            "", 
            "# amount is amount of shares to sell", 
            "# instead of inputting particip. num could just loop through array if dont have it", 
            "# @return error msg if fail, returns amount you get paid if success", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome, trading closed, or you haven't traded in this market", 
            "    # -2: entered a -amt of shares", 
            "    # -3: you own no shares / limit price too high", 
            "", 
            "    # -5: bad commitment or no commitment", 
            "    # -6: oracle only branch, no trading", 
            "def sellShares(branch, market, outcome, amount, limit):", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-6)", 
            "    sellInfo = array(4)", 
            "    sellInfo[0] = market", 
            "    sellInfo[1] = outcome", 
            "    sellInfo[2] = amount", 
            "    sellInfo[3] = limit", 
            "    sellHash = sha256(sellInfo, items=4)", 
            "    if(self.trades[market][tx.origin].hash != sellHash || block.number == self.trades[market][tx.origin].block):", 
            "        return(-5)", 
            "", 
            "    self.trades[market][tx.origin].hash = 0", 
            "", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):", 
            "        return(-4)", 
            "    n = 0", 
            "    #if event gets pushed back people can still buy / sell", 
            "    pushedBack = 0", 
            "    while n < numEvents:", 
            "        #if(EVENTS.getPushedBack(events[n])==0):", 
            "        if(1):", 
            "            n += 1", 
            "        # pushed back and not resolved", 
            "        elif(EVENTS.getOutcome(events[n])==0):", 
            "            pushedBack = 1", 
            "            n = numEvents", 
            "        else:", 
            "          n += 1", 
            "    if (MARKETS.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, -amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if oldCost <= newCost:", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-2)", 
            "    # these prices are in fixed point", 
            "    price = oldCost - newCost", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, revert", 
            "    if (MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount or (limit!=0 and (price*2^64/amount)<limit)):", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-3)", 
            "    else:", 
            "        # send bitcoin from the market to the user acc.", 
            "        CASH.subtractCash(market, price)", 
            "        fee = MARKETS.getTradingFee(market)*price/2^64", 
            "        # half of fees go to market creator", 
            "        CASH.addCash(INFO.getCreator(market), fee/2)", 
            "        # half go to branch", 
            "        CASH.addCash(branch, fee/2)", 
            "        price -= fee", 
            "        CASH.addCash(tx.origin, price)", 
            "        MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)", 
            "        # log new price and avg. price sold / share", 
            "        log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), (price)*2^64/amount)", 
            "        return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "buyShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "hash", 
                        "type": "int256"
                    }
                ], 
                "name": "commitTrade(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "makeMarketHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "sellShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "user", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cost", 
                        "type": "int256"
                    }
                ], 
                "name": "updatePrice(int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern buy&sellShares: [buyShares:[int256,int256,int256,int256,int256]:int256, commitTrade:[int256,int256]:int256, makeMarketHash:[int256,int256,int256,int256]:int256, sellShares:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "cash": {
        "address": "0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "data cashcoinBalances[]", 
            "", 
            "data owners[]", 
            "", 
            "def init():", 
            "    # test initial funds", 
            "    self.cashcoinBalances[tx.origin] = 100000*2^64", 
            "", 
            "# @return: cash balance of address", 
            "def balance(address):", 
            "    return(self.cashcoinBalances[address])", 
            "", 
            "# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...", 
            "# needs to be called when making a market, branch, etc. or a new cash user acc.", 
            "def initiateOwner(account):", 
            "    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):", 
            "        self.owners[account] = msg.sender", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)", 
            "# @return: value sent, 0 if fails", 
            "# If you've never used cash in augur, to initiate your account call this with value as 0", 
            "def send(recver, value):", 
            "    if(self.owners[tx.origin]==0):", 
            "        self.owners[tx.origin] = tx.origin", 
            "    if(self.owners[recver]==0):", 
            "        return(0)", 
            "    sender = tx.origin", 
            "    senderBalance = self.cashcoinBalances[sender]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[sender] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of cash sent; fail is 0", 
            "def sendFrom(recver, value, from):", 
            "    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.", 
            "    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)", 
            "    if(from!=tx.origin and msg.sender!=self.owners[from]):", 
            "        return(0)", 
            "    if(self.owners[recver]==0):", 
            "        return(0)", 
            "    senderBalance = self.cashcoinBalances[from]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[from] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# make sure only coming from specific contracts", 
            "def subtractCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "        return(0)", 
            "    self.cashcoinBalances[ID] -= amount", 
            "    return(1)", 
            "", 
            "def addCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "        return(0)", 
            "    self.cashcoinBalances[ID] += amount", 
            "    return(1)", 
            "", 
            "def setCash(address, balance):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[address] && tx.origin!=self.owners[address]):", 
            "        return(0)", 
            "    self.cashcoinBalances[address] = balance", 
            "    return(1)", 
            "", 
            "def depositEther():", 
            "    self.cashcoinBalances[msg.sender] += msg.value * 2^64 / 10^18", 
            "    return msg.value", 
            "", 
            "def withdrawEther(to, value):", 
            "    if(value < 0):", 
            "        return(-1)", 
            "    if self.cashcoinBalances[msg.sender] >= value * 2^64 / 10^18:", 
            "        self.cashcoinBalances[msg.sender] -= value * 2^64 / 10^18", 
            "        send(to, value)", 
            "        return 1", 
            "    else:", 
            "        return 0"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balance(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "depositEther()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "initiateOwner(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "send(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }
                ], 
                "name": "sendFrom(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "withdrawEther(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]"
    }, 
    "closeMarket": {
        "address": "0x35152caa07026203a1add680771afb690d872d7d", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern closeMarketOne: [oneOutcome:[int256,int256]:int256, valueCalcOne:[int256,int256]:int256]", 
            "CLOSEONE = 0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
            "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256, valueCalcTwo:[int256,int256[],int256[]]:int256]", 
            "CLOSETWO = 0x81a7621e9a286d061b3dea040888a51c96693b1c", 
            "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256, valueCalcFour:[int256,int256[],int256[]]:int256]", 
            "CLOSEFOUR = 0xabe47f122a496a732d6c4b38b3ca376d597d75dd", 
            "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256, valueCalcEight:[int256,int256[],int256[]]:int256]", 
            "CLOSEEIGHT = 0x9fe69262bbaa47f013b7dbd6ca5f01e17446c645", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "RESOLVE = 0x52ccb0490bc81a2ae363fccbb2b367bca546cec7", 
            "", 
            "# first param is the market, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "macro YES: 2^65", 
            "macro NO: 2^64", 
            "macro BAD: 3 * 2^63", 
            "", 
            "macro CATCH_TOLERANCE: 2^64 / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < 2^63):", 
            "        0", 
            "    elif($x > 2^63):", 
            "        2^64", 
            "    else:", 
            "        0", 
            "", 
            "# loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "# distribute coins among winning events", 
            "# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1", 
            "# Error messages otherwise", 
            "    # -1: Market has no cash anyway / already closed", 
            "    # -2: 0 outcome", 
            "    # -4: Outcome .5 once, pushback and retry", 
            "    # -6: bonded pushed forward market not ready to be resolved", 
            "    # -7: event not reportable >.99", 
            "#Use consistent 1 and 2 fixed point numbers as min and max for close market, make market, make event, buy/sell shares, and consensus on binary events - really, just use base 64 fixed point everywhere", 
            "def closeMarket(branch, market):", 
            "    if(CASH.balance(market)<=0):", 
            "        return(-1)", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 0", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getmode(events[i])==0):", 
            "            resolved = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    i = 0", 
            "    while i < numberEvents:", 
            "        numReports = MAKEREPORTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = MAKEREPORTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(numReports == numExpected && numReports!=0 && numExpected!=0):", 
            "            reportingDone = 1", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && !resolved):", 
            "        # loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "        n = 0", 
            "        outcomeFour = 0", 
            "        outcomeSix = 0", 
            "        while n < numberEvents:", 
            "            votingPeriodEvent = EVENTS.getExpiration(events[n])/BRANCHES.getPeriodLength(branch)", 
            "            fxpOutcome = EVENTS.getOutcome(events[n])", 
            "            resolution = 1", 
            "            if(MAKEREPORTS.getReportable(votingPeriodEvent, events[n])==-1):", 
            "                return(-7)", 
            "            if(EVENTS.getUncaughtOutcome(events[n])==0):", 
            "                return(-2)", 
            "            # TODO: if round 2 event && notFinal return 0", 
            "            if(binary(events[n]) && fxpOutcome==0):", 
            "                    resolution = RESOLVE.resolveBinary(events[n], market, branch, votingPeriodEvent, period)", 
            "            elif(scalar(events[n]) && EVENTS.getmode(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(2^64*EVENTS.getMinValue(events[n]), 2^64*EVENTS.getMaxValue(events[n]), event, market, branch, votingPeriodEvent, period)", 
            "            elif(categorical(events[n]) && EVENTS.getmode(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(2^64, 2^64*EVENTS.getNumOutcomes(events[n]), event, market, branch, votingPeriodEvent, period)", 
            "            if(resolution==-4):", 
            "                outcomeFour = 1", 
            "            elif(resolution==-6):", 
            "                outcomeSix = 1", 
            "            n += 1", 
            "        if(outcomeFour):", 
            "            return(-4)", 
            "        elif(outcomeSix):", 
            "            return(-6)", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = RESOLVE.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)", 
            "        MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "", 
            "        self.returnLiquidity(branch, market)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return 1 if success", 
            "# Errors:", 
            "    # 0: reporting not done", 
            "    # -1: trader doesn't exist", 
            "def claimProceeds(branch, market):", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 1", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        numReports = MAKEREPORTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = MAKEREPORTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getmode(events[i])==0):", 
            "            resolved = 0", 
            "        if(numReports != numExpected && numReports!=0 and numExpected!=0):", 
            "            reportingDone = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && resolved):", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = MARKET.getWinningOutcomes(market, outitems=8)", 
            "        outcome = 0", 
            "        if(winningOutcomes[1]==0):", 
            "            outcome = CLOSEONE.oneOutcome(market, winningOutcomes[0])", 
            "        elif(winningOutcomes[7]):", 
            "            outcome = CLOSEEIGHT.eightOutcomes(market, winningOutcomes, events)", 
            "        elif(winningOutcomes[3]):", 
            "            outcome = CLOSEFOUR.fourOutcomes(market, winningOutcomes, events)", 
            "        elif(winningOutcomes[1]):", 
            "            outcome = CLOSETWO.twoOutcomes(market, winningOutcomes, events)", 
            "        return(outcome)", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions", 
            "def returnLiquidity(branch, market):", 
            "    # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)", 
            "    # refund left over initial liquidity in market - half to market creator, other half to voters", 
            "    # *unless* it's a scaled decision, refund all initial liquidity left over to market creator", 
            "    # rest of money available in market + the additional trading fees divy up amongst reporters and market creator", 
            "    initialLiquidity = INFO.getCreationFee(market)", 
            "    winningOutcomes = array(8)", 
            "    winningOutcomes = MARKETS.getWinningOutcomes(market, outitems=8)", 
            "    valueOfShares = 0", 
            "    creator = INFO.getCreator(market)", 
            "    if(winningOutcomes[1]==0):", 
            "        valueOfShares = CLOSEONE.valueCalcOne(market, winningOutcomes[0])", 
            "    elif(winningOutcomes[7]):", 
            "        valueOfShares = CLOSEEIGHT.valueCalcEight(market, winningOutcomes, events)", 
            "    elif(winningOutcomes[3]):", 
            "        valueOfShares = CLOSEFOUR.valueCalcFour(market, winningOutcomes, events)", 
            "    elif(winningOutcomes[1]):", 
            "        valueOfShares = CLOSETWO.valueCalcTwo(market, winningOutcomes, events)", 
            "", 
            "    liquidityRemaining = CASH.balance(market) - valueOfShares", 
            "    if(liquidityRemaining<0):", 
            "        return(-1)", 
            "    # some scalar involved", 
            "    if(winningOutcomes[1]):", 
            "        if(liquidityRemaining > initialLiquidity):", 
            "            # pay back liquidity, split up excess profits", 
            "            CASH.addCash(creator, initialLiquidity)", 
            "            CASH.subtractCash(market, initialLiquidity)", 
            "            liquidityRemaining -= initialLiquidity", 
            "            CASH.addCash(branch, liquidityRemaining/2)", 
            "            CASH.addCash(creator, liquidityRemaining/2)", 
            "            CASH.subtractCash(market, liquidityRemaining)", 
            "        # send whatever's left of the initial liquidity to the creator", 
            "        else:", 
            "            CASH.addCash(creator, liquidityRemaining)", 
            "            CASH.subtractCash(market, liquidityRemaining)", 
            "    # no scalars", 
            "    else:", 
            "        # split up excess profits & liquidity", 
            "        CASH.addCash(branch, liquidityRemaining/2)", 
            "        CASH.addCash(creator, liquidityRemaining/2)", 
            "        CASH.subtractCash(market, liquidityRemaining)", 
            "    return(1)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and 2**64*EVENTS.getMaxValue($event)==2**65 and EVENTS.getMinValue($event)==1)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "claimProceeds(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "returnLiquidity(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarket: [claimProceeds:[int256,int256]:int256, closeMarket:[int256,int256]:int256, returnLiquidity:[int256,int256]:int256]"
    }, 
    "closeMarketEight": {
        "address": "0x9fe69262bbaa47f013b7dbd6ca5f01e17446c645", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "# eight winning outcomes", 
            "def eightOutcomes(market, winningOutcome: arr, events: arr):", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)", 
            "    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare = array(7)", 
            "    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        CASH.subtractCash(market, sharesOwned*pricePerShare[n]*MARKETS.getCumScale(market)/2^64)", 
            "        CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare[n]/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcEight(market, winningOutcome: arr, events: arr):", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)", 
            "    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare = array(7)", 
            "    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    sharesTotal3 = MARKETS.getSharesPurchased(market, winningOutcome[2]) - MARKETS.initialLiquidityAmount(market, winningOutcome[2])", 
            "    sharesTotal4 = MARKETS.getSharesPurchased(market, winningOutcome[3]) - MARKETS.initialLiquidityAmount(market, winningOutcome[3])", 
            "    sharesTotal5 = MARKETS.getSharesPurchased(market, winningOutcome[4]) - MARKETS.initialLiquidityAmount(market, winningOutcome[4])", 
            "    sharesTotal6 = MARKETS.getSharesPurchased(market, winningOutcome[5]) - MARKETS.initialLiquidityAmount(market, winningOutcome[5])", 
            "    sharesTotal7 = MARKETS.getSharesPurchased(market, winningOutcome[6]) - MARKETS.initialLiquidityAmount(market, winningOutcome[6])", 
            "    sharesTotal8 = MARKETS.getSharesPurchased(market, winningOutcome[7]) - MARKETS.initialLiquidityAmount(market, winningOutcome[7])", 
            "", 
            "    value = sharesTotal1*cumScale*pricePerShare[0]/2**64 + sharesTotal2*cumScale*pricePerShare[1]/2**64 + sharesTotal3*cumScale*pricePerShare[2]/2**64 + sharesTotal4*cumScale*pricePerShare[3]/2**64 + sharesTotal5*cumScale*pricePerShare[4]/2**64 + sharesTotal6*cumScale*pricePerShare[5]/2**64 + sharesTotal7*cumScale*pricePerShare[6]/2**64 + sharesTotal8*cumScale*pricePerShare[7]/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "eightOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcEight(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256, valueCalcEight:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketFour": {
        "address": "0xabe47f122a496a732d6c4b38b3ca376d597d75dd", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "# four winning outcomes", 
            "def fourOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalarOne = 0", 
            "    if(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by 2^64 to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low-low", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "        # high-low", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "        # low-high", 
            "        elif(n==2):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare3/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare3/2^64)", 
            "        # high-high", 
            "        elif(n==3):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare4/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare4/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcFour(market, winningOutcome: arr, events: arr):", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalarOne = 0", 
            "    if(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by 2^64 to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    sharesTotal3 = MARKETS.getSharesPurchased(market, winningOutcome[2]) - MARKETS.initialLiquidityAmount(market, winningOutcome[2])", 
            "    sharesTotal4 = MARKETS.getSharesPurchased(market, winningOutcome[3]) - MARKETS.initialLiquidityAmount(market, winningOutcome[3])", 
            "    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64 + sharesTotal3*cumScale*pricePerShare3/2**64 + sharesTotal4*cumScale*pricePerShare4/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "fourOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcFour(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256, valueCalcFour:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketOne": {
        "address": "0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "", 
            "# mutex result non scalar not .5", 
            "# one winning outcome", 
            "def oneOutcome(market, winningOutcome):", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome, -sharesOwned)", 
            "    CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market))", 
            "    CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market))", 
            "    return(1)", 
            "", 
            "def valueCalcOne(market, winningOutcome):", 
            "    sharesTotal = MARKETS.getSharesPurchased(market, winningOutcome) - MARKETS.initialLiquidityAmount(market, winningOutcome)", 
            "    return(sharesTotal*MARKETS.getCumScale(market))"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "oneOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "valueCalcOne(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketOne: [oneOutcome:[int256,int256]:int256, valueCalcOne:[int256,int256]:int256]"
    }, 
    "closeMarketTwo": {
        "address": "0x81a7621e9a286d061b3dea040888a51c96693b1c", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "# # of winningOutcomes is 2", 
            "def twoOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalar = 0", 
            "    elif(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        scalar = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = 2^64 - pricePerShare2", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low side", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "        # high side (of the scalar part)", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcTwo(market, winningOutcome: arr, events: arr):", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalar = 0", 
            "    elif(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        scalar = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = 2^64 - pricePerShare1", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "twoOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcTwo(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256, valueCalcTwo:[int256,int256[],int256[]]:int256]"
    }, 
    "consensus": {
        "address": "0x6c4c9fa11d6d8ed2c7a08ddcf4d4654c85194f68", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "", 
            "# round two consensus data", 
            "data bondPaid[]", 
            "data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)", 
            "", 
            "# branch takes a branchID", 
            "    # denominator takes a vote period", 
            "    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total", 
            "    # penalizedUpTo is the latest period a user has done the penalization for", 
            "    # fees collected states whether for a given period a user collected fees", 
            "    # rep collected states whether for a given period a user collected rep", 
            "data branch[](denominator[], penalized[][](event[], num, notEnoughReportsPenalized), penalizedUpTo[], feesCollected[][])", 
            "", 
            "#1. Record rep at start of report period [before rep in make reports]", 
            "#2. Penalize for each event", 
            "#3. Each reporter needs to do this for all events they reported on, if not get docked", 
            "#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees", 
            "#5. If you don't do it for all events or don't penalize for not reporting enough, autolose 20% rep each period one does this (b/c they're trying to cheat)", 
            "# Errors:", 
            "    # -1: pushed back event already resolved, so can't redistribute rep based off of its original expected expiration period", 
            "    # -2: already past first half of new period and needed to penalize before then", 
            "    # -3: need to do not enough reports penalization [or lackthereof]", 
            "def penalizeWrong(branch, event):", 
            "    repBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    if(!self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized):", 
            "        return(-3)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    # accounts for if no events in a period", 
            "    if(EXPEVENTS.getNumberEvents(branch, lastPeriod)==0):", 
            "        self.branch[branch].penalizedUpTo[tx.origin] = lastPeriod", 
            "        self.branch[branch].denominator[lastPeriod] += repBalance", 
            "        return(1)", 
            "", 
            "    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event) && MARKETS.getPushedForward(market)):", 
            "        if(lastPeriod==EVENTS.getOriginalExpiration(event)/BRANCHES.getPeriodLength(branch)):", 
            "            return(-1)", 
            "    outcome = EVENTS.getOutcome(event)", 
            "    reportValue = MAKEREPORTS.getReport(branch, lastPeriod, event)", 
            "    p = self.proportionCorrect(event)", 
            "    oldRep = MAKEREPORTS.getBeforeRep(branch, lastPeriod)", 
            "    if(!self.branch[branch].penalized[lastPeriod][tx.origin].event[event] && reportValue && outcome!=0):", 
            "        # wrong", 
            "        #184467440737095520 == 0.01 in fxp", 
            "        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):", 
            "            #if(scalar(event) or categorical(event) or outcome==3*2**64):", 
            "                #p = -(abs(reportValue - EVENTS.getmode(event))/2) + 2**64", 
            "            newRep = oldRep*(2*p - 2**64)/2**64", 
            "        # right", 
            "        else:", 
            "            #if(scalar(event) or categorical(event) or outcome==3*2**64):", 
            "                #p = -(abs(reportValue - EVENTS.getmode(event))/2) + 2**64", 
            "            newRep = oldRep*(2*(2**64-p)**2 / p + 2**64)/2**64", 
            "        #smoothedRep = oldRep*.8 + newRep*.2", 
            "        smoothedRep = oldRep * 14757395258967642112/2**64 + newRep * 3689348814741910528/2**64", 
            "        repChange = smoothedRep - oldRep", 
            "        newAfterRep = MAKEREPORTS.getAfterRep(branch, lastPeriod) + repChange", 
            "        MAKEREPORTS.setAfterRep(branch, lastPeriod, newAfterRep)", 
            "        self.branch[branch].penalized[lastPeriod][tx.origin].event[event] = 1", 
            "        self.branch[branch].penalized[lastPeriod][tx.origin].num += 1", 
            "        if(MAKEREPORTS.getNumReportsActual(branch, lastPeriod)==self.branch[branch].penalized[lastPeriod][tx.origin].num):", 
            "            if(newAfterRep <= 0):", 
            "                newAfterRep = 0", 
            "            self.branch[branch].penalizedUpTo[tx.origin] = lastPeriod", 
            "            self.branch[branch].denominator[lastPeriod] += newAfterRep", 
            "            totalRepDifference = newAfterRep - oldRep", 
            "            if(repBalance + totalRepDifference <= 0):", 
            "                totalRepDifference = -1*repBalance", 
            "            if(totalRepDifference<0):", 
            "                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, tx.origin), totalRepDifference)", 
            "                # sends that rep to the branch", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "        return(1)", 
            "    else:", 
            "        return(lastPeriod)", 
            "", 
            "# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account and distributed like trading fees.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep", 
            "# Errors:", 
            "    # -1: already done", 
            "    # -2: hasn't reported this period", 
            "def penalizeNotEnoughReports(branch):", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    if(self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized):", 
            "        return(-1)", 
            "    # accounts for if no events in a period", 
            "    if(EXPEVENTS.getNumberEvents(branch, lastPeriod)==0):", 
            "        self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized = 1", 
            "        return(1)", 
            "", 
            "    if(!hasReported(branch, lastPeriod)):", 
            "        return(-2)", 
            "    numEvents = MAKEREPORTS.getNumEventsToReport(branch, lastPeriod)", 
            "    # min. of 30 events no matter how little rep you have", 
            "    if(numEvents < 30*2**64):", 
            "        numEvents = 30*2**64", 
            "    repConstant = REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch)", 
            "    logOutput = FXP.fx_log(repConstant)", 
            "    exp = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "    exp += 18446744073709552", 
            "    total = exp*40", 
            "    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)", 
            "    if(total > 2**64):", 
            "        numEvents = (EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)/40)*2**64", 
            "    # what _if_ there are actually <30 events in augur?", 
            "        # perhaps we should have all reporters in that period report on all of them", 
            "    numReportsActual = MAKEREPORTS.getNumReportsActual(branch, lastPeriod)", 
            "    if(numEvents/(2*2**64) > MAKEREPORTS.getNumReportsActual(branch, lastPeriod)):", 
            "        originalRep = REPORTING.getRepBalance(branch, tx.origin)", 
            "        # penalize people", 
            "        newRep = 3689348814741910528*numReportsActual*originalRep / MAKEREPORTS.getNumEventsToReport(branch, lastPeriod)", 
            "        oldRep = originalRep*14757395258967642112 / 2**64", 
            "        repChange = (oldRep+newRep) - originalRep", 
            "        # removes rep from reporter who lost it", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, tx.origin), repChange)", 
            "        # sends that rep to the branch rep pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -repChange)", 
            "        MAKEREPORTS.setBeforeRep(branch, lastPeriod, oldRep+newRep)", 
            "        MAKEREPORTS.setAfterRep(branch, lastPeriod, oldRep+newRep)", 
            "    self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized = 1", 
            "    return(1)", 
            "", 
            "# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]", 
            "    # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission", 
            "def collectFees(branch):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual < periodLength/2):", 
            "        return(-2)", 
            "    if(!repRedistributionDone(branch, tx.origin)):", 
            "        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary", 
            "        return(-1)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch) - 1", 
            "    if(!self.branch[branch].feesCollected[lastPeriod][tx.origin] && hasReported(branch, lastPeriod)):", 
            "        newRep = MAKEREPORTS.getAfterRep(branch, lastPeriod)", 
            "        denominator = self.branch[branch].denominator[lastPeriod]", 
            "        gainedRep = newRep * 2**64 / denominator * REPORTING.getRepBalance(branch, branch) / 2**64", 
            "        #if(lostRep) newRep should be == MAKEREPORTS.getAfterRep(branch, period) + gainedRep", 
            "        #if(gainedRep) newRep should be == MAKEREPORTS.getBeforeRep(branch, period) + gainedRep", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, tx.origin), gainedRep)", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), gainedRep)", 
            "        cash = BRANCHES.getInitialBalance(branch, lastPeriod) * newRep / denominator", 
            "        CASH.addCash(tx.origin, cash)", 
            "        CASH.subtractCash(branch, cash)", 
            "        self.branch[branch].feesCollected[lastPeriod][tx.origin] = 1", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# call when a user who hasn't reported for a while wants to start again and needs to catch up on penalizations", 
            "def penalizationCatchup(branch):", 
            "    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    # find delta between this last period and last penalized up to", 
            "    lastPeriodPenalized = self.branch[branch].penalizedUpTo[tx.origin]", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    oldRep = REPORTING.getRepBalance(branch, tx.origin)", 
            "    if(lastPeriodPenalized!=lastPeriod && !hasReported(branch, lastPeriod)):", 
            "        # dock 10% for each period they didn't penalize on", 
            "        smoothedRep = oldRep*16602069666338596864/2**64", 
            "        i = 1", 
            "        while i < delta:", 
            "            smoothedRep = smoothedRep*16602069666338596864/2**64", 
            "            i += 1", 
            "        # and send it to branch for penalty rep collection", 
            "        repChange = oldRep - smoothedRep", 
            "        # removes rep from reporter who lost it", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, tx.origin), repChange)", 
            "        # sends that rep to the branch rep pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), repChange)", 
            "        self.branch[branch].penalizedUpTo[tx.origin] = lastPeriod", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "", 
            "# anti cheat provide ballot and randomNum mechanism steal deposit", 
            "# Returns:", 
            "    # 0: not a valid claim", 
            "    # -2: reporter doesn't exist", 
            "def slashRep(branch, salt, report, reporter, eventID):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, eventID)", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = reporter", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    if(reportHash!=realHash):", 
            "        return(0)", 
            "    else:", 
            "        reporterIndex = REPORTING.repIDToIndex(branch, reporter)", 
            "        trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "        # if the truther's rep. account doesn't exist, make one", 
            "        if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):", 
            "            trutherIndex = REPORTING.getNumberReporters(branch)", 
            "            REPORTING.addReporter(branch, tx.origin)", 
            "        if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):", 
            "            return(-2)", 
            "        reporterBalance = REPORTING.getRepBalance(branch, reporter)", 
            "        REPORTING.setRep(branch, reporterIndex, 0)", 
            "        trutherBalance = REPORTING.getRepBalance(branch, tx.origin)", 
            "        REPORTING.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*2**63 / 2**64))", 
            "    return(reporterBalance)", 
            "", 
            "def incrementPeriodAfterReporting(branch):", 
            "    # do this after reporting is finished", 
            "    if(periodOver(branch)):", 
            "        BRANCHES.incrementPeriod(branch)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions:", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "def proportionCorrect(event, branch, period):", 
            "    p = 0", 
            "    outcome = EVENTS.getOutcome(event)", 
            "    if(outcome!=0):", 
            "        # binary", 
            "        if(EVENTS.getNumOutcomes(event)==2 and 2**64*EVENTS.getMaxValue(event)==2**65 and 2**64*EVENTS.getMinValue(event)==2**64):", 
            "            # subtract 1 to get it from 0 to 1", 
            "            avgOutcome = EVENTS.getUncaughtOutcome(event) - 2**64", 
            "            # say we have outcome of 0, avg is .4, what is p?", 
            "            # p is .6 or 60%", 
            "            if(outcome == 2**64):", 
            "                p = 2**64 - avgOutcome", 
            "            # say we have outcome of 1, avg is .8, what is p (proportion correct)?", 
            "            # p is .8 or 80%", 
            "            if(outcome == 2 * 2**64):", 
            "                p = avgOutcome", 
            "            if(outcome == 3 * 2**63):", 
            "                return(0)", 
            "        return(p)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro periodOver($branch):", 
            "    # what the current vote period should be", 
            "    currentVotePeriod = block.number / BRANCHES.getPeriodLength($branch) - 1", 
            "    # if actual vote period is less than what the current one should be, return 1, it can be incremented", 
            "    if(BRANCHES.getVotePeriod($branch) < currentVotePeriod):", 
            "        1", 
            "    else:", 
            "        0", 
            "", 
            "macro hasReported($branch, $period):", 
            "    MAKEREPORTS.getReportedPeriod($branch, $period, tx.origin)", 
            "", 
            "macro repRedistributionDone($branch, $reporter):", 
            "    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]", 
            "    lastPeriod = BRANCHES.getVotePeriod($branch)-1", 
            "    if(lastPeriod==lastPeriodPenalized):", 
            "        1", 
            "    else:", 
            "        0", 
            "", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and 2**64*EVENTS.getMaxValue($event)==2**65 and EVENTS.getMinValue($event)==1)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "# test bonded pushed forward event/market though not ready to be resolved", 
            "    # code in penalize for that:", 
            "        #elif(rejected && rejectedPeriodOver && && actuallyrejected && MAKEREPORTS.getReport(branch, lastPeriodperiod, event) && !self.penalized[lastPeriod][tx.origin].event[event] && outcome):", 
            "        #  outcome = 2**63", 
            "        #  mode = 2**63", 
            "        #   p = self.proportionCorrect(event, rejected)", 
            "        #   oldRep = MAKEREPORTS.getBeforeRep(branch, period)", 
            "        #   # wrong", 
            "        #   if(reportValue > outcome+.01 or reportValue < outcome-.01):", 
            "        #       if(scalar or categorical or .5):", 
            "        #         # scalar/cat are 0 - 1, binary .5 are 1-2 and 1.5", 
            "        #     # should be outcome since mode is the same", 
            "        #           p = -(abs(reportValue - mode)/2) + 1", 
            "        #       newRep = oldRep*(2*p -1)", 
            "        #   # right", 
            "        #   else:", 
            "        #       if(scalar or categorical or .5):", 
            "        #           p = -(abs(reportValue - mode)/2) + 1", 
            "        #       newRep = oldRep*(2*(1-p)**2 / p + 1)", 
            "        #   smoothedRep = oldRep*.8 + newRep*.2", 
            "        #   MAKEREPORTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))", 
            "        # repChange = smoothedRep - oldRep", 
            "        # if(repChange < 0):", 
            "        #   sendToRedistribPool", 
            "        # # need to except round two events from this when added", 
            "        # if(MAKEREPORTS.getNumReportsActual(branch, lastPeriod)==self.penalized[lastPeriod][tx.origin].num):", 
            "        #   self.totalRepPenalized[period] += oldRep", 
            "        #   self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)", 
            "        # self.penalized[lastPeriod][tx.origin].event[event] = 1", 
            "        # self.penalized[lastPeriod][tx.origin].num += 1", 
            "        #   return(1)", 
            "# test .99 resolve push forward"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "collectFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriodAfterReporting(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizationCatchup(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeNotEnoughReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeWrong(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "proportionCorrect(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "slashRep(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern consensus: [collectFees:[int256]:int256, incrementPeriodAfterReporting:[int256]:int256, penalizationCatchup:[int256]:int256, penalizeNotEnoughReports:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256,int256,int256]:int256, slashRep:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "createBranch": {
        "address": "0x8c19616de17acdfbc933b99d9f529a689d22098f", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "", 
            "# period length is given in blocks", 
            "# @return branchID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: no money for creation fee or branch already exists", 
            "def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):", 
            "    if(periodLength<=0 || !BRANCHES.getPeriodLength(parent) || description==0):", 
            "        return(-1)", 
            "", 
            "    parentPeriod = BRANCHES.getVotePeriod(parent)", 
            "", 
            "    branchInfo = string(8*32+len(description))", 
            "    branchInfo[0] = BRANCH                                      #typecode", 
            "    branchInfo[1] = tx.origin                                   #creator address", 
            "    branchInfo[2] = 47*2^64                                     #creation fee", 
            "    branchInfo[3] = periodLength                                #length of voting cycle", 
            "    branchInfo[4] = block.number                                #current block number", 
            "    branchInfo[5] = parent                                      #branchID of parent branch", 
            "    branchInfo[6] = tradingFee", 
            "    branchInfo[7] = oracleOnly", 
            "    mcopy(branchInfo+ 8*32, description, len(description))", 
            "    # people can check that these characteristics hash to the ID if they want", 
            "    # people can hand a friend their new branch hash && characteristics && say, \"don't trust me? check\"", 
            "    branchID = sha256(branchInfo, chars=len(branchInfo))", 
            "    currentVotePeriod = (block.number / periodLength) - 1", 
            "    if(INFO.getCreator(branchID)==0):", 
            "        BRANCHES.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod)", 
            "    else:", 
            "        return(-2)", 
            "    if(INFO.getCreator(parent) && CASH.send(parent, 47*2^64) && INFO.setInfo(branchID, description, tx.origin, 47*2^64) && REPORTING.setInitialReporters(parent, branchID)):", 
            "        return(branchID)", 
            "    else:", 
            "        return(-2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }
                ], 
                "name": "createSubbranch(bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createEvent": {
        "address": "0x5069d883e31429c6dd1325d961f443007747c7a2", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0", 
            "# to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # 0: not enough money to pay fees or event already exists", 
            "    # -2: max value < min value", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if(maxValue < minValue):", 
            "        return(-2)", 
            "    if periodLength && description != 0 && expDate > block.number:", 
            "        eventinfo = string(8*32 + len(description))", 
            "        eventinfo[0] = EVENT                                        #typecode", 
            "        eventinfo[1] = branch                                       #branchID", 
            "        eventinfo[2] = expDate                                      #expiration date", 
            "        eventinfo[3] = tx.origin                                    #creator address", 
            "        eventinfo[4] = 42*2^64                                      #creation fee", 
            "        eventinfo[5] = minValue                                     #minimum outcome value", 
            "        eventinfo[6] = maxValue                                     #maximum outcome value", 
            "        eventinfo[7] = numOutcomes                                  #number of outcomes", 
            "        mcopy(eventinfo + 8*32, description, len(description))", 
            "        eventID = sha256(eventinfo, chars=len(eventinfo))", 
            "    else:", 
            "        return(-1)", 
            "    if(numOutcomes < 2 || numOutcomes > 50):", 
            "        return(0)", 
            "    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    participationFactor = (EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-2) * 2^64) / EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-1)", 
            "    if participationFactor == 0:", 
            "        participationFactor = 1", 
            "    CASH.initiateOwner(eventID)", 
            "    # send fee and bond", 
            "    if CASH.balance(tx.origin) >= (42*2^64 + participationFactor*45):", 
            "        if !INFO.getCreator(eventID) && !EVENTS.getEventBranch(eventID) && CASH.send(eventID, 42*2^64) && CASH.send(branch, participationFactor*45):", 
            "            # see which future period it expires in && put the event in that bin", 
            "            # event voting periods - expDate / periodLength gives you the voting period #", 
            "            futurePeriod = expDate / periodLength", 
            "            if INFO.setInfo(eventID, description, tx.origin, participationFactor*45) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes):", 
            "                return(eventID)", 
            "            else:", 
            "                return(0)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createMarket": {
        "address": "0x3f3276849a878a176b2f02dd48a483e8182a49e4", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "", 
            "event creationBlock(market:indexed)", 
            "", 
            "", 
            "# alpha is a fixedpoint number / calc. it in UI", 
            "# z is the optimal initial vector for each outcome", 
            "# z = liquidity / (1+(alpha*n*ln(n)))", 
            "    # n is num outcomes", 
            "# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set", 
            "# tradingFee is a percent in fixedPoint", 
            "# same for these values", 
            "# @return marketID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: too many events", 
            "    # -3: too many outcomes", 
            "    # -4: not enough money or market already exists", 
            "    # -5: fee too low", 
            "    # -6: duplicate events", 
            "    # -7: event already expired", 
            "", 
            "# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)", 
            "def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr, forkSelection):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    # liquidity is just buying complete sets then selling at diff. prices", 
            "    # minimum fee 2% with initial liquidity >= $50 and < $100", 
            "    if(initialLiquidity<100*2**64):", 
            "        if(tradingFee<368934881474191032):", 
            "            return(-5)", 
            "    # minimum fee 1% with initial liquidity >= $100 and < $1000", 
            "    if(initialLiquidity<1000*2**64):", 
            "        if(tradingFee<184467440737095516):", 
            "            return(-5)", 
            "    # minimum fee 0.5% with initial liquidity < $2000", 
            "    if(initialLiquidity<2000*2**64):", 
            "        if(tradingFee<92233720368547758):", 
            "            return(-5)", 
            "    # minimum fee 0.4% with initial liquidity < $3000", 
            "    if(initialLiquidity<3000*2**64):", 
            "        if(tradingFee<73786976294838206):", 
            "            return(-5)", 
            "    # minimum fee 0.3% with initial liquidity < $4000", 
            "    if(initialLiquidity<4000*2**64):", 
            "        if(tradingFee<55340232221128654):", 
            "            return(-5)", 
            "    # minimum fee 0.2% with initial liquidity < $5000", 
            "    if(initialLiquidity<5000*2**64):", 
            "        if(tradingFee<36893488147419103):", 
            "            return(-5)", 
            "    # minimum fee 0.1% with initial liquidity >= $5000", 
            "    if(initialLiquidity>=5000*2**64):", 
            "        if(tradingFee<18446744073709551):", 
            "            return(-5)", 
            "", 
            "    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets", 
            "    if(periodLength==0 or len(description)==0 or (initialLiquidity<50*2**64 and !BRANCHES.getOracleOnly(branch)) || alpha <= 2^57 || tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "    # minimum initial liquidity for \"oracle only\" branches is less (half is a fee, half returned)", 
            "    if(initialLiquidity<2*2**64):", 
            "        return(-1)", 
            "    event = events[0]", 
            "", 
            "    # check that events have same exp. dates && branch", 
            "    i = 0", 
            "    eventNum = len(events)", 
            "", 
            "    # only supports 3 dimensional markets atm", 
            "    if(eventNum > 3):", 
            "        return(-2)", 
            "", 
            "    numOutcomes = 0", 
            "    eventsConcat = 0", 
            "    cumulativeScale = 0", 
            "    tradingPeriod = 0", 
            "    while i < eventNum:", 
            "        event = events[i]", 
            "        if(i!=0):", 
            "            if(event==events[i-1]):", 
            "                return(-6)", 
            "        expirationDate = EVENTS.getExpiration(event)", 
            "        futurePeriod = expirationDate / periodLength", 
            "        if(expirationDate < block.number):", 
            "            return(-7)", 
            "        EXPEVENTS.addEvent(branch, futurePeriod, event)", 
            "        if(expirationDate > tradingPeriod):", 
            "            tradingPeriod = expirationDate", 
            "        eventsConcat += event", 
            "        if (EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):", 
            "            return(-1)", 
            "        #scalars", 
            "        maxValue = EVENTS.getMaxValue(event)", 
            "        minValue = EVENTS.getMinValue(event)", 
            "        if((maxValue!=2 || minValue !=1) && EVENTS.getNumOutcomes(event)==2):", 
            "            # is a valid scalar", 
            "            cumulativeScale += maxValue - EVENTS.getMinValue(event)", 
            "        eventNumOutcomes = EVENTS.getNumOutcomes(event)", 
            "        if(i==0):", 
            "            numOutcomes += eventNumOutcomes", 
            "        else:", 
            "            numOutcomes *= eventNumOutcomes", 
            "        i += 1", 
            "    if(numOutcomes > 80):", 
            "        return(-3)", 
            "    if(cumulativeScale==0):", 
            "        cumulativeScale = 1", 
            "    tradingPeriod = (tradingPeriod / periodLength)", 
            "", 
            "    # formation of marketID (hash)", 
            "    marketinfo = string(11*32 + len(description))", 
            "    marketinfo[0] = MARKET", 
            "    marketinfo[1] = tx.origin", 
            "    marketinfo[2] = initialLiquidity", 
            "    marketinfo[3] = branch", 
            "    marketinfo[4] = eventsConcat", 
            "    marketinfo[5] = len(events)", 
            "    marketinfo[6] = cumulativeScale", 
            "    marketinfo[7] = alpha", 
            "    marketinfo[8] = numOutcomes", 
            "    marketinfo[9] = tradingPeriod", 
            "    marketinfo[10] = tradingFee", 
            "    mcopy(marketinfo + 11*32, description, chars=len(description))", 
            "    marketID = sha256(marketinfo, chars=len(marketinfo))", 
            "    log(type=creationBlock, marketID)", 
            "    CASH.initiateOwner(marketID)", 
            "    # pay numOutcomes fee", 
            "    # if it's already been created return 0", 
            "    if(!CASH.send(branch, numOutcomes*2^63) || INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):", 
            "        return(-4)", 
            "", 
            "    # buy some of all outcomes", 
            "    # ls-lmsr needs at least a very small initial liquidity", 
            "    y = 1", 
            "    z = initialLiquidity * 2**64 / (cumulativeScale*2**64 + alpha*numOutcomes*cumulativeScale*FXP.fx_log(numOutcomes*2**64)/2**64)", 
            "    MARKETS.initialLiquiditySetup(marketID, alpha, cumulativeScale, numOutcomes)", 
            "    while y <= numOutcomes:", 
            "        MARKETS.modifyShares(marketID, y, z)", 
            "        MARKETS.setInitialLiquidityAmount(marketID, y, z)", 
            "        y += 1", 
            "    if(INFO.setInfo(marketID, description, tx.origin, initialLiquidity) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, forkSelection) && CASH.send(marketID, initialLiquidity)):", 
            "        i = 0", 
            "        while i < len(events):", 
            "            EVENTS.addMarket(events[i], marketID)", 
            "            i += 1", 
            "        return(marketID)", 
            "", 
            "    # revert shares bought and other variables", 
            "    else:", 
            "        v = 1", 
            "        while v <= numOutcomes:", 
            "            MARKETS.modifyShares(marketID, v, -z)", 
            "            v += 1", 
            "        MARKETS.initialLiquiditySetup(marketID, 0, 0, 0)", 
            "        return(-4)", 
            "", 
            "# todo: needs to comply w/ new trading fee rules", 
            "# perhaps don't allow raising of trading fee", 
            "def updateTradingFee(branch, market, tradingFee):", 
            "    if(tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "    return(MARKETS.setTradingFee(market, tradingFee))", 
            "", 
            "#Add def moveMarket(market, newBranch, marketAuthor) in case of a fork or some other issue", 
            "#In event of fork:", 
            "#1) Market Maker chooses the fork", 
            "#2) Market is closed at current prices", 
            "#3) The market is unable to go to adjudication upon close date and closes at final prices.", 
            "#4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.", 
            "#5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex", 
            "#6) market is moved to the fork with a higher market cap as defined by centralized exchange y", 
            "def moveMarketAndAssocEvents(market, fork):", 
            "    #if(self.stuffForked()):", 
            "    if(1):", 
            "        forkChoice = MARKETS.getForkSelection(market)", 
            "", 
            "        # set market branch", 
            "        # move event", 
            "        # move market as well to whichever fork", 
            "", 
            "        #1) Market Maker chooses the fork", 
            "        if(forkChoice==1):", 
            "            if(INFO.getCreator(market)==msg.sender):", 
            "                return(0)", 
            "        #2) Market is closed at current prices", 
            "        elif(forkChoice==2):", 
            "            return(0)", 
            "        #3) The market is unable to go to adjudication upon close date and closes at final prices.", 
            "        elif(forkChoice==3):", 
            "            return(0)", 
            "        #4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.", 
            "        # should this be weighted by capital in the market? hmm", 
            "        elif(forkChoice==4):", 
            "            return(0)", 
            "        #5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex", 
            "        elif(forkChoice==5):", 
            "            return(0)", 
            "        #6) market is moved to the fork with a higher market cap as defined by centralized exchange y", 
            "        elif(forkChoice==6):", 
            "            return(0)", 
            "        #7) autonocoin style bet which fork it should go on and that's the one (like futarchy, except you don't get a refund)", 
            "        elif(forkChoice==7):", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "", 
            "# Anyone can post an \"Early Resolution Bond\"", 
            "# This bond is equal to 0.5 * Market_Fee * Market_Value", 
            "# This amount is the amount needed to pay the reporters in case this was frivolous.", 
            "# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'", 
            "    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)", 
            "# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration dateevent", 
            "# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.", 
            "def pushMarketForward(branch, market):", 
            "    # todo: if has been pushed forward in the past (see close market) don't allow it again", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    if(marketClosed):", 
            "        return(0)", 
            "    if(CASH.send(market, numEvents*MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))==0):", 
            "        return(0)", 
            "    i = 0", 
            "    # for each event in market", 
            "    while i < numEvents:", 
            "        if(eventNotResolved && eventNotInRound2Adj):", 
            "            event = MARKETS.getMarketEvent(market, i)", 
            "            # push into next vote period", 
            "            period = BRANCHES.getVotePeriod(branch)", 
            "            EXPEVENTS.addEvent(branch, period+1, event)", 
            "            # set event expiration date to be after the current reporting period ends", 
            "            EVENTS.setExpiration(event, block.number)", 
            "            MARKETS.setTradingPeriod(market, period+1)", 
            "            MARKETS.setPushedForward(market, 1)", 
            "            #MAKEREPORTS.setReportable(period+1, event)", 
            "        i += 1", 
            "    return(1)", 
            "", 
            "", 
            "# - If at anytime after expiry an event's market's odds are <.99, someone can prove it and push it into next reporting period", 
            "# (and don't allow rbrr for original exp period of this market, actually, don't allow this regardless)", 
            "# - Should probably still have an option to pay to resolve in case something somehow goes wrong here or people really want a market resolved.", 
            "#def resolve99Market(branch, market, resolveRegardless):", 
            "#    if(eventIsScalar || marketClosed):", 
            "#      return(-1)", 
            "#    if(marketNotExpired):", 
            "#      return(-2)", 
            "#    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "#    n = 0", 
            "#    ninetynine = 0", 
            "#    while n < numOutcomes:", 
            "#      if(MARKETS.price(markets, n) > 18262276632972456099):", 
            "#        ninetynine = 1", 
            "#        n = numOutcomes", 
            "#        n += 1", 
            "", 
            "#    if(ninetynine==0 || resolveRegardless):", 
            "#      if(resolveRegardless):", 
            "#        if(CASH.send(branch, 100*2**64)==0):", 
            "#            return(0)", 
            "", 
            "#    numEvents = MARKETS.getNumEvents(market)", 
            "#    i = 0", 
            "#    # for each event in market", 
            "#    while i < numEvents:", 
            "#      if(eventNotResolved && eventNotInRound2Adj):", 
            "#        event = MARKETS.getMarketEvent(market, i)", 
            "        # push into next vote period", 
            "#        period = BRANCHES.getVotePeriod(branch)", 
            "#        EXPEVENTS.addEvent(branch, period+1, event)", 
            "        # set event expiration date to be after the current reporting period ends", 
            "#        EVENTS.setExpiration(event, block.number)", 
            "#        MARKETS.setTradingPeriod(market, period+1)", 
            "#        MAKEREPORTS.setReportable(period+1, event)", 
            "#      i += 1", 
            "#    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initialLiquidity", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "forkSelection", 
                        "type": "int256"
                    }
                ], 
                "name": "createMarket(int256,bytes,int256,int256,int256,int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fork", 
                        "type": "int256"
                    }
                ], 
                "name": "moveMarketAndAssocEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "pushMarketForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }
                ], 
                "name": "updateTradingFee(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "creationBlock(int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern createMarket: [createMarket:[int256,bytes,int256,int256,int256,int256[],int256]:int256, moveMarketAndAssocEvents:[int256,int256]:int256, pushMarketForward:[int256,int256]:int256, updateTradingFee:[int256,int256,int256]:int256]"
    }, 
    "createSingleEventMarket": {
        "address": "0xc1c4e2f32e4b84a60b8b7983b6356af4269aab79", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256]:int256]", 
            "CREATEEVENT = 0x5069d883e31429c6dd1325d961f443007747c7a2", 
            "extern createMarket: [createMarket:[int256,bytes,int256,int256,int256,int256[],int256]:int256, moveMarketAndAssocEvents:[int256,int256]:int256, pushMarketForward:[int256,int256]:int256, updateTradingFee:[int256,int256,int256]:int256]", 
            "CREATEMARKET = 0x3f3276849a878a176b2f02dd48a483e8182a49e4", 
            "", 
            "def createSingleEventMarket(branch, description:str, expirationBlock, minValue, maxValue, numOutcomes, alpha, initialLiquidity, tradingFee, forkSelection):", 
            "    # with eventID = CREATEEVENT.createEvent(branch, description, expirationBlock, minValue, maxValue, numOutcomes):", 
            "    #     with marketID = CREATEMARKET.createMarket(branch, description, alpha, initialLiquidity, tradingFee, [eventID], forkSelection):", 
            "    #         return(marketID)", 
            "    return(CREATEMARKET.createMarket(branch, description, alpha, initialLiquidity, tradingFee, [CREATEEVENT.createEvent(branch, description, expirationBlock, minValue, maxValue, numOutcomes)], forkSelection))"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expirationBlock", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initialLiquidity", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkSelection", 
                        "type": "int256"
                    }
                ], 
                "name": "createSingleEventMarket(int256,bytes,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createSingleEventMarket: [createSingleEventMarket:[int256,bytes,int256,int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "eventResolution": {
        "address": "0x52ccb0490bc81a2ae363fccbb2b367bca546cec7", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "", 
            "macro YES: 2^65", 
            "macro NO: 2^64", 
            "macro BAD: 3 * 2^63", 
            "macro CATCH_TOLERANCE: 2^64 / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < (2^63 - CATCH_TOLERANCE)):", 
            "        0", 
            "    elif($x > (2^63 + CATCH_TOLERANCE)):", 
            "        2^64", 
            "    else:", 
            "        0", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "def catch(x):", 
            "    return(catch(x))", 
            "", 
            "## helper functions:", 
            "def resolveBinary(event, market, branch, votingPeriodEvent, period):", 
            "    fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    pushedBack = EVENTS.getPushedBack(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration date", 
            "    if(fxpOutcome == 3*2**63 && MARKETS.getPushedForward(market)):", 
            "        #set event expiration to be the old date prior to this bond process", 
            "        EVENTS.setExpiration(event, EVENTS.getOriginalExpiration(event))", 
            "        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))", 
            "        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        MARKETS.setPushedForward(market, 0)", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        EVENTS.setmode(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        # need to store uncaught outcome for rejectedperiod separately as well as which period it was \"rejected\" in", 
            "        EVENTS.setRejected(event, EVENTS.getExpiration(event)/periodLength, fxpOutcome)", 
            "        return(-6)", 
            "    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome", 
            "    # why residual < periodLength/2?", 
            "    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        #push back event", 
            "        #MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        #MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #EVENTS.setEthics(event, 0)", 
            "        #EXPEVENTS.addEvent(branch, period+1, event)", 
            "        #set outcome to 0", 
            "        #EVENTS.setOutcome(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        #EVENTS.setUncaughtOutcome(event, 0)", 
            "        #set pushedback to true", 
            "        #EVENTS.setPushedBack(event)", 
            "        #set event expiration date to be after the current reporting period ends", 
            "        #EVENTS.setExpiration(event, block.number)", 
            "        #MARKETS.setTradingPeriod(market, period+1)", 
            "        #return(-4)", 
            "    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "    else:", 
            "        # return bond", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(INFO.getCreator(event), 42*2**64)", 
            "        if(MARKETS.getPushedForward(market)):", 
            "            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            # delete old event from future events exp", 
            "            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(event)/periodLength)", 
            "    return(1)", 
            "", 
            "def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent, period):", 
            "    mode = EVENTS.getUncaughtOutcome(event)", 
            "    EVENTS.setmode(event, mode)", 
            "    fxpOutcome = mode * (scaled_max - scaled_min) + scaled_min", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    pushedBack = EVENTS.getPushedBack(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "", 
            "    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration date", 
            "    if(fxpOutcome == 3*2**63 && MARKETS.getPushedForward(market)):", 
            "        #set event expiration to be the old date prior to this bond process", 
            "        EVENTS.setExpiration(event, EVENTS.getOriginalExpiration(event))", 
            "        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))", 
            "        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        MARKETS.setPushedForward(market, 0)", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        EVENTS.setmode(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        # need to store uncaught outcome for rejectedperiod separately as well as which period it was \"rejected\" in", 
            "        EVENTS.setRejected(event, EVENTS.getExpiration(event)/periodLength, fxpOutcome)", 
            "        return(-6)", 
            "", 
            "    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome", 
            "    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        EVENTS.setmode(event, fxpOutcome)", 
            "        #push back event", 
            "        #MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        #MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #EXPEVENTS.addEvent(branch, period+1, event)", 
            "        #set outcome to 0", 
            "        #EVENTS.setOutcome(event, 0)", 
            "        #set pushedback to true", 
            "        #EVENTS.setPushedBack(event)", 
            "        # set mode to 0", 
            "        #EVENTS.setmode(event, 0)", 
            "        #EVENTS.setEthics(event, 0)", 
            "        #EVENTS.setExpiration(event, block.number)", 
            "        #MARKETS.setTradingPeriod(market, period+1)", 
            "        #return(-4)", 
            "    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        EVENTS.setmode(event, fxpOutcome)", 
            "    else:", 
            "        # return bond", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(INFO.getCreator(event), 42*2**64)", 
            "        if(MARKETS.getPushedForward(market)):", 
            "            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            # delete old event from future events exp", 
            "            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(event)/periodLength)", 
            "    return(1)", 
            "", 
            "def determineWinningOutcomes(events: arr, numberEvents, branch, market):", 
            "    n = 0", 
            "    winningOutcomes = array(8)", 
            "    while n < numberEvents:", 
            "        fxpOutcome = EVENTS.getOutcome(events[n])", 
            "        outcome = fxpOutcome/2^64", 
            "        if(n==0):", 
            "            #scalar or .5", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                winningOutcomes[0] = 1", 
            "                winningOutcomes[1] = 2", 
            "            # anything besides scalar or .5", 
            "            else:", 
            "                winningOutcomes[0] += outcome", 
            "        elif(n==1):", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                # scalar, scalar", 
            "                if(winningOutcomes[1]):", 
            "                    winningOutcomes[2] = 3", 
            "                    winningOutcomes[3] = 4", 
            "                # nonscalar, scalar", 
            "                else:", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] = winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-1])", 
            "            # scalar, nonscalar", 
            "            elif(winningOutcomes[1]):", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "                winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "            # nonscalar, nonscalar", 
            "            else:", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "        elif(n==2):", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                #scalar, scalar, scalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[4] = 5", 
            "                    winningOutcomes[5] = 6", 
            "                    winningOutcomes[6] = 7", 
            "                    winningOutcomes[7] = 8", 
            "                #scalar, nonscalar, scalar", 
            "                #nonscalar, scalar, scalar", 
            "                elif(winningOutcomes[1]):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    #winningOutcomes[1] = winningOutcomes[1]", 
            "                    winningOutcomes[2] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                    winningOutcomes[3] += winningOutcomes[1] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                #nonscalar, nonscalar, scalar", 
            "                elif(winningOutcomes[1]==0):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "            else:", 
            "                #scalar, scalar, nonscalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[2] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[3] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #scalar, nonscalar, nonscalar", 
            "                #nonscalar, scalar, nonscalar", 
            "                elif(winningOutcomes[1]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #nonscalar, nonscalar, nonscalar", 
            "                else:", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "        n+=1", 
            "    return(winningOutcomes: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "catch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "numberEvents", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "determineWinningOutcomes(int256[],int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveBinary(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "scaled_min", 
                        "type": "int256"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveCategoricalOrScalar(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "events": {
        "address": "0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "", 
            "# Events' index is the eventID", 
            "# a binary outcome has 0 for min && 1 for max value, but consensus will return 2^64 and 2^65 respectively", 
            "# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1", 
            "# S&P 500 scalar would be say 0 && 4700, respectively", 
            "# categorical markets have fixed point min and max", 
            " # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)", 
            "data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, numReports, mode, uncaughtOutcome, final, ethical, originalExp, rejected, rejectedPeriod, rejectedUncaught, pushedBack)", 
            "", 
            "def getEventInfo(event):", 
            "    info = array(6)", 
            "    info[0] = self.Events[event].branch", 
            "    info[1] = self.Events[event].expirationDate", 
            "    info[2] = self.Events[event].outcome", 
            "    info[3] = self.Events[event].minValue", 
            "    info[4] = self.Events[event].maxValue", 
            "    info[5] = self.Events[event].numOutcomes", 
            "    return(info: arr)", 
            "", 
            "def getEventBranch(event):", 
            "\treturn(self.Events[event].branch)", 
            "", 
            "def getPushedBack(event):", 
            "\treturn(self.Events[event].pushedBack)", 
            "", 
            "def getExpiration(event):", 
            "\treturn(self.Events[event].expirationDate)", 
            "", 
            "def getOriginalExpiration(event):", 
            "\treturn(self.Events[event].originalExp)", 
            "", 
            "def setExpiration(event, date):", 
            "\tself.Events[event].expirationDate = date", 
            "\treturn(1)", 
            "", 
            "def getOutcome(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].outcome)", 
            "", 
            "def getEthics(event):", 
            "\treturn(self.Events[event].ethical)", 
            "", 
            "def setEthics(event, ethicality):", 
            "\tself.Events[event].ethical = ethicality", 
            "\treturn(ethicality)", 
            "", 
            "def getEthical(event):", 
            "\treturn(self.Events[event].ethical)", 
            "", 
            "def getFinal(event):", 
            "\treturn(self.Events[event].final)", 
            "", 
            "def getMinValue(event):", 
            "\treturn(self.Events[event].minValue)", 
            "", 
            "def getMaxValue(event):", 
            "\treturn(self.Events[event].maxValue)", 
            "", 
            "def getNumOutcomes(event):", 
            "\treturn(self.Events[event].numOutcomes)", 
            "", 
            "def setUncaughtOutcome(event, outcome):", 
            "\tself.Events[event].uncaughtOutcome = outcome", 
            "\treturn(1)", 
            "", 
            "def getUncaughtOutcome(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].uncaughtOutcome)", 
            "", 
            "def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes):", 
            "\t# check that msg.sender is one of our function contracts", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Events[ID].expirationDate==0):", 
            "\t\tself.Events[ID].branch = branch", 
            "\t\tself.Events[ID].expirationDate = expirationDate", 
            "\t\tself.Events[ID].originalExp = originalExp", 
            "\t\tself.Events[ID].minValue = minValue", 
            "\t\tself.Events[ID].maxValue = maxValue", 
            "\t\tself.Events[ID].numOutcomes = numOutcomes", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def addMarket(event, marketID):", 
            "\tself.Events[event].markets[self.Events[event].numMarkets] = marketID", 
            "\tself.Events[event].numMarkets += 1", 
            "\treturn(1)", 
            "", 
            "def getMarkets(event):", 
            "\ti = 0", 
            "\tmarkets = array(self.Events[event].numMarkets)", 
            "\twhile i < self.Events[event].numMarkets:", 
            "\t\tmarkets[i] = self.Events[event].markets[i]", 
            "\t\ti += 1", 
            "\treturn(markets: arr)", 
            "", 
            "def getMarket(event, marketIndex):", 
            "\treturn(self.Events[event].markets[marketIndex])", 
            "", 
            "def getNumMarkets(event):", 
            "\treturn(self.Events[event].numMarkets)", 
            "", 
            "def setOutcome(ID, outcome):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Events[ID].outcome = outcome", 
            "\treturn(1)", 
            "", 
            "#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.", 
            "def setReportingThreshold(event):", 
            "\t# first check is if event expDate is in the current vote period and second is if blockNum is near expiration of voting period (within 7200 blocks or 24 hr.)", 
            "\t# final check is if < 25 reports so far", 
            "\t# (block.number+7200) / BRANCHES.getPeriodLength(branch) -1 is what we're reporting on in 24 hr", 
            "\t# vote period + 1 is the next vote period", 
            "\t# so if in 24 hr we'd be in the next vote period, we're within 24 hr of the end of this one", 
            "\tif(BRANCHES.getVotePeriod(self.Events[event].branch)==self.Events[event].expirationDate/BRANCHES.getPeriodLength(self.Events[event].branch) and (((block.number+7200) / BRANCHES.getPeriodLength(branch)) - 1)==(BRANCHES.getVotePeriod(self.Events[event].branch)+1) and self.Events[event].numReports<25):", 
            "\t\tself.Events[event].threshold = 2**192", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def getNumReports(event):", 
            "\treturn(self.Events[event].numReports)", 
            "", 
            "def addNumReports(event):", 
            "\tself.Events[event].numReports += 1", 
            "\treturn(1)", 
            "", 
            "def getReportingThreshold(event):", 
            "\treturn(self.Events[event].threshold)", 
            "", 
            "def getmode(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].mode)", 
            "", 
            "def setmode(event, mode):", 
            "\tself.Events[event].mode = mode", 
            "\treturn(1)", 
            "", 
            "def setFinal(event, final):", 
            "\tself.Events[event].final = 1", 
            "\treturn(1)", 
            "", 
            "def setRejected(event, period, uncaughtOutcome):", 
            "\tself.Events[event].rejected = 1", 
            "\tself.Events[event].rejectedPeriod = period", 
            "\tself.Events[event].rejectedUncaught = uncaughtOutcome", 
            "\treturn(1)", 
            "", 
            "def setPushedBack(event):", 
            "\tself.Events[event].pushedBack = 1", 
            "\treturn(1)", 
            "", 
            "def getRejected(event):", 
            "\treturn(self.Events[event].rejected)", 
            "", 
            "def getRejectedPeriod(event):", 
            "\treturn(self.Events[event].rejectedPeriod)", 
            "", 
            "def getRejectedUncaught(event):", 
            "\treturn(self.Events[event].rejectedUncaught)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "addNumReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthical(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthics(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMaxValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejected(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedUncaught(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getUncaughtOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getmode(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expirationDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeEvent(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthics(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "date", 
                        "type": "int256"
                    }
                ], 
                "name": "setExpiration(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "final", 
                        "type": "int256"
                    }
                ], 
                "name": "setFinal(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "uncaughtOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setRejected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setUncaughtOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mode", 
                        "type": "int256"
                    }
                ], 
                "name": "setmode(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]"
    }, 
    "expiringEvents": {
        "address": "0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have receive a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "", 
            "# [branchID][votingPeriod]", 
            "# reporthash is [reporterID] = hash", 
            "data EventsExpDates[][](numberEvents, numberRemoved, events[], totalRepReported, numEventsToReportOn, reportHash[][], periodVolume)", 
            "", 
            "data EventIDToIndex[][]", 
            "", 
            "# With this function you can get the eventIDs and report on outcomes", 
            "# @return all events in a branch and expiration period", 
            "def getEvents(branch, expDateIndex):", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventIndex(period, eventID):", 
            "\treturn(self.EventIDToIndex[period][eventID])", 
            "", 
            "# we should probably make this bonded too", 
            "# -1: voting not started", 
            "def setNumEventsToReportOn(branch, expDateIndex):", 
            "\t# after voting has started", 
            "\tif(expDateIndex==BRANCHES.getVotePeriod(branch)):", 
            "\t\tnumEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "\t\tnumberToReportOnEstimate = (numEvents-self.EventsExpDates[branch][expDateIndex].numberRemoved)*40", 
            "\t\tself.EventsExpDates[branch][expDateIndex].numEventsToReportOn = numberToReportOnEstimate", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(-1)", 
            "", 
            "", 
            "def getNumEventsToReportOn(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)", 
            "", 
            "def getPeriodVolume(branch, expIndex):", 
            "\treturn(self.EventsExpDates[branch][expIndex].periodVolume)", 
            "", 
            "def getNumberEvents(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].numberEvents)", 
            "", 
            "def getEvent(branch, expDateIndex, eventIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].events[eventIndex])", 
            "", 
            "def getTotalRepReported(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].totalRepReported)", 
            "", 
            "def getReportHash(branch, expDateIndex, reporter, event):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addEvent(branch, futurePeriod, eventID):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID", 
            "\tself.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "\tself.EventsExpDates[branch][futurePeriod].numberEvents += 1", 
            "\treturn(1)", 
            "", 
            "def removeEvent(branch, period):", 
            "\tself.EventsExpDates[branch][period].numberRemoved += 1", 
            "\treturn(1)", 
            "", 
            "def setTotalRepReported(branch, expDateIndex, repReported):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].totalRepReported = repReported", 
            "\treturn(1)", 
            "", 
            "def addPeriodVolume(branch, expIndex, volume):", 
            "\tself.EventsExpDates[branch][expIndex].periodVolume += volume", 
            "\treturn(1)", 
            "", 
            "def setReportHash(branch, expDateIndex, reporter, reportHash, event):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash", 
            "\treturn(1)", 
            "", 
            "def moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    x = 0", 
            "    while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):", 
            "        self.EventsExpDates[branch][currentPeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]", 
            "        self.EventIDToIndex[currentPeriod][self.EventsExpDates[branch][currentVotePeriod-1].events[x]] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "        self.EventsExpDates[branch][currentPeriod].numberEvents += 1", 
            "        # sub and set old period event to 0 poss.?", 
            "        x += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "futurePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "addEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "volume", 
                        "type": "int256"
                    }
                ], 
                "name": "addPeriodVolume(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodVolume(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRepReported(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "moveEventsToCurrentPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "removeEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repReported", 
                        "type": "int256"
                    }
                ], 
                "name": "setTotalRepReported(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]"
    }, 
    "faucets": {
        "address": "0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation OU", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact jack@augur.net or joey@augur.net.", 
            "", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "", 
            "# Error -1: Hey, you're not broke!", 
            "def cashFaucet():", 
            "    if CASH.balance(tx.origin) > 5*2**64:", 
            "        return(-1)", 
            "    CASH.setCash(tx.origin, 10000*2**64)", 
            "    return(1)", 
            "", 
            "def reputationFaucet(branch):", 
            "    index = 0", 
            "    if REPORTING.repIDToIndex(branch, tx.origin) != 0 or REPORTING.getReporterID(branch, 0) == tx.origin:", 
            "        index = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    else:", 
            "        index = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, tx.origin)", 
            "    REPORTING.setRep(branch, index, 47*2**64)", 
            "    return(1)", 
            "", 
            "def fundNewAccount(branch):", 
            "    CASH.send(self, 0)", 
            "    self.reputationFaucet(branch)", 
            "    CASH.setCash(tx.origin, 10000*2^64)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [], 
                "name": "cashFaucet()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "fundNewAccount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "reputationFaucet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern faucets: [cashFaucet:[]:int256, fundNewAccount:[int256]:int256, reputationFaucet:[int256]:int256]"
    }, 
    "fxpFunctions": {
        "address": "0x708fdfe18bf28afe861a69e95419d183ace003eb", 
        "code": [
            "macro fx_floor_log2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $lo = 0:", 
            "            with $hi = 191:", 
            "                with $mid = ($hi + $lo)/2:", 
            "                    while (($lo + 1) != $hi):", 
            "                        if $y < 2**$mid:", 
            "                            $hi = $mid", 
            "                        else:", 
            "                            $lo = $mid", 
            "                        $mid = ($hi + $lo)/2", 
            "                    $lo", 
            "", 
            "macro fx_log2_small($x):", 
            "    with $result = -0x48A49EAD9B2CD16BE:", 
            "        with $temp = $x:", 
            "            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_log2($x):", 
            "    with $y = fx_floor_log2($x):", 
            "        with $z = $x / 2**$y:", 
            "            $y * 0x10000000000000000 + fx_log2_small($z)", 
            "", 
            "macro fx_log($x):", 
            "    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177", 
            "", 
            "macro fx_exp2_small($x):", 
            "    with $result = 0x10000000000000000:", 
            "        with $temp = $x:", 
            "            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xE35846B82505F32*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA184897C5558D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x162C023B2A1D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1B5250C02BF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E87B8E21*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1C768AA3*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x164F0A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result + 0x1B08D3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_exp2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $z = $x % 0x10000000000000000:", 
            "            fx_exp2_small($z) * 2**$y", 
            "", 
            "macro fx_exp($x):", 
            "    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)", 
            "", 
            "def fx_exp(x):", 
            "\treturn(fx_exp(x))", 
            "", 
            "def fx_log(x):", 
            "\treturn(fx_log(x))", 
            "", 
            "def sqrt(n):", 
            "    val = n", 
            "    i = 0", 
            "    while i < 11:", 
            "        val = (val + n*2^64/val)/2", 
            "        i += 1", 
            "    return val"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_exp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_log(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "n", 
                        "type": "int256"
                    }
                ], 
                "name": "sqrt(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]"
    }, 
    "info": {
        "address": "0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "", 
            "# Every entity in our contract has similar metadata.", 
            "# Instead of putting it in each entity, we put all the", 
            "# metadata here.", 
            "# Info's index is the hash of the item we're getting info on", 
            "data Info[](description[2048], descriptionLength, creator, creationFee)", 
            "", 
            "def init():", 
            "    description = text(\"Root branch\")", 
            "    save(self.Info[1010101].description[0], description, chars=len(description))", 
            "    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826", 
            "    self.Info[1010101].creationFee = 10", 
            "    self.Info[1010101].descriptionLength = len(description)", 
            "", 
            "def getDescription(ID):", 
            "\tlength=self.Info[ID].descriptionLength", 
            "\treturn(load(self.Info[ID].description[0], chars=length): str)", 
            "", 
            "def getDescriptionLength(ID):", 
            "\treturn(self.Info[ID].descriptionLength)", 
            "", 
            "def getCreator(ID):", 
            "\treturn(self.Info[ID].creator)", 
            "", 
            "def getCreationFee(ID):", 
            "\treturn(self.Info[ID].creationFee)", 
            "", 
            "# @return 1 if success, 0 if creator already exists", 
            "def setInfo(ID, description: str, creator, fee):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\t# check that msg.sender is one of our function contracts", 
            "\tif(self.Info[ID].creator == 0):", 
            "\t\tsave(self.Info[ID].description[0], description, chars=len(description))", 
            "\t\tself.Info[ID].descriptionLength = len(description)", 
            "\t\tself.Info[ID].creationFee = fee", 
            "\t\tself.Info[ID].creator = creator", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreator(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescription(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescriptionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setInfo(int256,bytes,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]"
    }, 
    "makeReports": {
        "address": "0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "", 
            "# branches: votePeriod, reporterID (for both num hash submitted and num actual reports submitted) --- votePeriod, EventID --- eventID", 
            "data branches[](submittedHash[][], numReportsActual[][], hasReported[][](reported[]), beforeRep[][], afterRep[][], report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], reportedPeriod[][], firstReport[])", 
            "data reportable[][]", 
            "data mode_items[][](report_value[], current_mode, current_mode_items)", 
            "", 
            "", 
            "# need to finish this req. events stuff for round 2 pushback _and_:", 
            "\t# what _if_ there are actually <30 events in augur?", 
            "\t\t# perhaps we should have all reporters in that period report on all of them", 
            "", 
            "data requiredEvents[]", 
            "#self.Events[event].threshold = 2**256", 
            "# branch, period as params", 
            "data numReqEvents[][]", 
            "data upToDateOnRR[]", 
            "", 
            "def getReportedPeriod(branch, period, reporter):", 
            "\treturn(self.branches[branch].reportedPeriod[period][reporter])", 
            "", 
            "def getReportable(votePeriod, eventID):", 
            "\treturn(self.reportable[votePeriod][eventID])", 
            "", 
            "def setReportable(votePeriod, eventID):", 
            "\tself.reportable[votePeriod][eventID] = 1", 
            "\treturn(1)", 
            "", 
            "# Return 0 means already required", 
            "def setEventRequired(branch, period, event):", 
            "\tif(self.requiredEvents[event]==0):", 
            "\t\tself.requiredEvents[event] = 1", 
            "\t\tself.numReqEvents[branch][period] += 1", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def getRRUpToDate():", 
            "\treturn(self.upToDateOnRR[msg.sender])", 
            "", 
            "def setRRUpToDate():", 
            "\tself.upToDateOnRR[msg.sender] = 1", 
            "\treturn(1)", 
            "", 
            "def getNumReportsExpectedEvent(branch, votePeriod, eventID):", 
            "\treturn(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])", 
            "", 
            "def getNumReportsEvent(branch, votePeriod, eventID):", 
            "\treturn(self.branches[branch].numReportsEvent[votePeriod][eventID])", 
            "", 
            "def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):", 
            "\tself.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num", 
            "\treturn(1)", 
            "", 
            "def setNumReportsEvent(branch, votePeriod, eventID, num):", 
            "\tself.branches[branch].numReportsEvent[votePeriod][eventID] = num", 
            "\treturn(1)", 
            "", 
            "def getReport(branch, period, event):", 
            "\treturn(self.branches[branch].report[period][tx.origin].event[event])", 
            "", 
            "def getBeforeRep(branch,period):", 
            "\treturn(self.branches[branch].beforeRep[period][tx.origin])", 
            "", 
            "def getAfterRep(branch, period):", 
            "\treturn(self.branches[branch].afterRep[period][tx.origin])", 
            "", 
            "def setBeforeRep(branch, period, rep):", 
            "\tself.branches[branch].beforeRep[period][tx.origin] = rep", 
            "\treturn(rep)", 
            "", 
            "def setAfterRep(branch, period, rep):", 
            "\tself.branches[branch].afterRep[period][tx.origin] = rep", 
            "\treturn(rep)", 
            "", 
            "def getNumReportsActual(branch, votePeriod):", 
            "\treturn(self.branches[branch].numReportsActual[tx.origin][votePeriod])", 
            "", 
            "def getSubmittedHash(branch, period, reporter):", 
            "\treturn(self.branches[branch].submittedHash[period][reporter])", 
            "", 
            "def makeHash(salt, report, eventID):", 
            "\thashInfo = array(4)", 
            "\thashInfo[0] = tx.origin", 
            "\thashInfo[1] = salt", 
            "\thashInfo[2] = report", 
            "\thashInfo[3] = eventID", 
            "\treportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "\treturn(reportHash)", 
            "", 
            "# Error 0: couldn't set report hash", 
            "# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet", 
            "# Error -2: not in hash submitting timeframe or event doesn't exist / not a valid event expiring then", 
            "# Error -4: already resolved", 
            "# Error -5: .99 market", 
            "# Error -6: no markets", 
            "def submitReportHash(branch, reportHash, votePeriod, eventID, eventIndex):", 
            "\tif(BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "\t\treturn(-1)", 
            "\t# make sure event is in the given branch...", 
            "\teventsID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "\tif(eventsID!=eventID || eventID == 0 || eventsID == 0):", 
            "\t\treturn(-2)", 
            "\tif(EVENTS.getOutcome(eventID)!=0):", 
            "\t\treturn(-4)", 
            "\tif(self.reportable[votePeriod][eventID]==-1):", 
            "\t\treturn(-5)", 
            "\tif(!self.upToDateOnRR[msg.sender]):", 
            "\t\t# TODO: calls to consensus functions and in send rep", 
            "\t\t#doIt()", 
            "\t\tself.upToDateOnRR[msg.sender] = 1", 
            "\t#todo: if period isn't incremented, do it", 
            "", 
            "\trepIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "\tperiodLength = BRANCHES.getPeriodLength(branch)", 
            "\tresidual = block.number % periodLength", 
            "\tcurrentExpPeriod = (block.number / periodLength)", 
            "", 
            "\tif(REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):", 
            "\t\treturn(-1)", 
            "", 
            "\tif(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):", 
            "\t\tEXPEVENTS.setNumEventsToReportOn(branch, votePeriod)", 
            "", 
            "\t# Whoever the first person to try to submit a report for period x on market y with events events checks if it needs to be reported on or not.", 
            "\tif(self.reportable[votePeriod][eventID]==0):", 
            "\t\tneedsReportingOn = self.needsReportingOn(eventID)", 
            "\t\t# if yes, the value is 1 and everything proceeds normally", 
            "\t\tif(BRANCHES.getOracleOnly(branch)):", 
            "\t\t\tneedsReportingOn = 1", 
            "\t\tself.reportable[votePeriod][eventID] = needsReportingOn", 
            "\t\t# If not, then no one can report on this market's event(s) and the event is \"removed\" from expEvents.", 
            "\t\tif(needsReportingOn==-1):", 
            "\t\t\tEXPEVENTS.removeEvent(branch, votePeriod)", 
            "\t\t\treturn(-5)", 
            "", 
            "\treportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)", 
            "\tif(reportingThreshold==-6):", 
            "\t\treturn(-6)", 
            "\tx = array(1)", 
            "\tx[0] = tx.origin + eventID", 
            "\tshaHash = sha3(x, items=1)/2**64", 
            "\tif(residual < periodLength/2 && (shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(eventID))):", 
            "\t\t# don't increment num reports expected or numreportshash per reporter for updated commitment, just the first time", 
            "\t\tif(EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, eventID)==0):", 
            "\t\t\tself.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1", 
            "\t\t# submit hash of (tx.origin, salt, Votes[])", 
            "\t\tif(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash, eventID)):", 
            "\t\t\t# if first report commitment this period", 
            "\t\t\tif(self.branches[branch].submittedHash[period][msg.sender]==0):", 
            "\t\t\t\tself.branches[branch].submittedHash[period][msg.sender] = 1", 
            "\t\t\treturn(1)", 
            "\t\telse:", 
            "\t\t\treturn(0)", 
            "\telse:", 
            "\t\treturn(-2)", 
            "", 
            "# @return 1 if success", 
            "# Error messages", 
            "\t# -1: has already reported", 
            "\t# -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet", 
            "\t# -3: hash doesn't match", 
            "\t# -4: no rep", 
            "\t# -5: bad report", 
            "\t# -6: hash not low enough", 
            "\t# -8: invalid event", 
            "\t# -9: already resolved", 
            "\t# -10: <24 hr left in period, too late to report, able to put up readj. bonds though", 
            "def submitReport(branch, votePeriod, eventIndex, salt, report, eventID, ethics):", 
            "\tif(self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod]==1):", 
            "\t\treturn(-1)", 
            "\t# if currentExpPeriod is more than 2 periods past the current vote period", 
            "\t# then there can be no more voting for that voting period", 
            "\t# (reasoning being: >=1 period past means all the events in that period have expired)", 
            "\t# (>=2 periods past mean the events have exp. & people have had 1 full period to vote)", 
            "\t# currently requires events to expire to vote", 
            "\tperiodLength = BRANCHES.getPeriodLength(branch)", 
            "\tcurrentExpPeriod = (block.number / periodLength)", 
            "\trepIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "\tif (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1) || BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "\t\treturn(-2)", 
            "\tif(REPORTING.getRepBalance(branch, tx.origin)<10*2**64):", 
            "\t\treturn(-4)", 
            "\t# make sure event is in the given branch and vote period...", 
            "\tevent = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "\tif(event==0 || eventID!=event):", 
            "\t\treturn(-8)", 
            "\tif(EVENTS.getOutcome(eventID)!=0):", 
            "\t\treturn(-9)", 
            "\t#if(block.number/BRANCHES.getPeriodLength(branch)!=((block.number + 4800)/BRANCHES.getPeriodLength(branch))):", 
            "\t#    return(-10)", 
            "\t#if(feesNotCollected && hasReportedLastPeriod):", 
            "\t#    doItOrReturn0", 
            "\tx = array(1)", 
            "\tx[0] = tx.origin + eventID", 
            "\treportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)", 
            "\t# in fxp (2**192) == 2**256 / 2**64", 
            "\t# TODO / need:", 
            "\t\t# coefficient for reporting minimum based off of appeals", 
            "\t\t#Base Reporter Amount = 3+(200*Appeal_Ratio)^3", 
            "\t\t#This keeps the base reporter amount 3-10 until it starts getting over 1%, it makes 2% 67 and 3% 219", 
            "\t\t#Calculated as opposed to a global variable that slowly changes over time that is.", 
            "\t\t#I think perhaps the target number of reports per reporter could be something like   150+Base_Reporter_Amount", 
            "\tshaHash = sha3(x, items=1)/2**64", 
            "\tif(shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(eventID)):", 
            "\t\tresidual = block.number % periodLength", 
            "\t\tif(residual > periodLength/2):", 
            "\t\t\trealHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, eventID)", 
            "\t\t\treportHash = self.makeHash(salt, report, eventID)", 
            "\t\t\tif(reportHash!=realHash):", 
            "\t\t\t\t(return(-3))", 
            "\t\t\tif(self.branches[branch].firstReport[votePeriod]==0):", 
            "\t\t\t\tBRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))", 
            "\t\t\t\tself.branches[branch].firstReport[votePeriod] = 1", 
            "\t\t\treport = self.validateReport(eventID, branch, votePeriod, report)", 
            "\t\t\tif(report == -5):", 
            "\t\t\t\treturn(-5)", 
            "\t\t\t# reporter has reported for 1 more event", 
            "\t\t\tself.branches[branch].numReportsActual[tx.origin][votePeriod] += 1", 
            "\t\t\t# record that reporter has reported for this event", 
            "\t\t\tself.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod] = 1", 
            "\t\t\t# set report value for event", 
            "\t\t\tself.branches[branch].report[votePeriod][tx.origin].event[eventID] = report", 
            "\t\t\t# set ethics value for event", 
            "\t\t\tif(ethics!=2**64 || ethics!=0):", 
            "\t\t\t\tethics = 2**64", 
            "\t\t\tethics = (EVENTS.getEthics(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)", 
            "\t\t\tEVENTS.setEthics(eventID, ethics)", 
            "\t\t\t# add 1 report to the event", 
            "\t\t\tself.branches[branch].numReportsEvent[votePeriod][eventID] += 1", 
            "\t\t\t# if 1st report of the period for a reporter", 
            "\t\t\tif(!self.branches[branch].reportedPeriod[votePeriod][tx.origin]):", 
            "\t\t\t\trepReported = EXPEVENTS.getTotalRepReported(branch)", 
            "\t\t\t\tbalance = REPORTING.getRepBalance(branch, tx.origin)", 
            "\t\t\t\trepReported += balance", 
            "\t\t\t\tEXPEVENTS.setTotalRepReported(branch, votePeriod, repReported)", 
            "\t\t\t\t#Record rep at start of report period", 
            "\t\t\t\tself.branches[branch].beforeRep[votePeriod][tx.origin] = balance", 
            "\t\t\t\tself.branches[branch].afterRep[votePeriod][tx.origin] = balance", 
            "\t\t\t\tself.branches[branch].reportedPeriod[votePeriod][tx.origin] = 1", 
            "\t\t\treturn(1)", 
            "\t\treturn(-2)", 
            "\telse:", 
            "\t\treturn(-6)", 
            "", 
            "### Helper functions:", 
            "def calculateReportingThreshold(branch, eventID, votePeriod):", 
            "\tnumMarkets = EVENTS.getNumMarkets(eventID)", 
            "\tif(numMarkets==0):", 
            "\t\treturn(-6)", 
            "\tif(numMarkets>100):", 
            "\t\tnumMarkets = 100", 
            "\tmarkets = array(numMarkets)", 
            "\tmarkets = EVENTS.getMarkets(eventID, outitems=numMarkets)", 
            "\tvolume = 0", 
            "\ti = 0", 
            "\twhile i < numMarkets:", 
            "\t\t# may be best to store vol here", 
            "\t\tvolume += MARKETS.getVolume(markets[i])", 
            "\t\ti += 1", 
            "\ttotalVol = EXPEVENTS.getPeriodVolume(branch, votePeriod)", 
            "\t# if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64", 
            "\tlogOutput = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))", 
            "\trepConstant = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "\trepConstant += 18446744073709552", 
            "\tvolFraction = 0", 
            "\tif(totalVol!=0):", 
            "\t\tvolFraction = volume*2**64/totalVol", 
            "\tnumEvents = self.getNumEventsToReport(branch, votePeriod)", 
            "\tif(numEvents < 30*2**64):", 
            "\t\trepConstant = 30*2**128/numEvents", 
            "\t# in fxp (2**128) == 2**192 / 2**64", 
            "\treportingThreshold = 40*((-(267*volFraction**2)/(2*2**64) + (533*volFraction)/2 + 1*2**64)*repConstant/2**64) * (2**128)", 
            "\treturn(reportingThreshold)", 
            "", 
            "#a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))", 
            "# returns num events to report on in fxp", 
            "def getNumEventsToReport(branch, votePeriod):", 
            "\tprelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)", 
            "\trepConstant = REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch)", 
            "\tlogOutput = FXP.fx_log(repConstant)", 
            "\texp = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "\texp += 18446744073709552", 
            "\ttotal = exp*prelim + self.numReqEvents[branch][votePeriod]*2**64", 
            "\treturn(total)", 
            "", 
            "def needsReportingOn(event):", 
            "\t# This only works for categorical and binary markets, not scalar", 
            "\tif((2^64*EVENTS.getMaxValue(events[n]) != 2*2**64 || 2^64*EVENTS.getMinValue(events[n]) != 2**64) and EVENTS.getNumOutcomes(events[n]) == 2):", 
            "\t\treturn(1)", 
            "\t# To determine whether a market needs to be resolved or not, the events can only have one market associated with them or all markets associated with the event fulfill the .99 qualification.", 
            "\tnumMarkets = EVENTS.getNumMarkets(event)", 
            "\tmarkets = array(numMarkets)", 
            "\tmarkets = EVENTS.getMarkets(event, outitems=numMarkets)", 
            "\tif(numMarkets>100):", 
            "\t\treturn(1)", 
            "\ti = 0", 
            "\t# todo optimize perf. here", 
            "\twhile i < numMarkets:", 
            "\t\tnumOutcomes = MARKETS.getMarketNumOutcomes(markets[i])", 
            "\t\tn = 1", 
            "\t\tninetynine = 0", 
            "\t\twhile n <= numOutcomes:", 
            "\t\t\tif(MARKETS.price(markets[i], n) > 18262276632972456099):", 
            "\t\t\t\tninetynine = 1", 
            "\t\t\t\tn = numOutcomes+1", 
            "\t\t\tn += 1", 
            "\t\tif(ninetynine == 0):", 
            "\t\t\treturn(1)", 
            "\t\ti += 1", 
            "\t# doesn't need reporting on, meets the .99 qualification", 
            "\treturn(-1)", 
            "", 
            "def validateReport(eventID, branch, votePeriod, report):", 
            "\t# check report validity", 
            "\tnumOutcomes = EVENTS.getNumOutcomes(eventID)", 
            "\tmaxValue = EVENTS.getMaxValue(eventID)", 
            "\tminValue = EVENTS.getMinValue(eventID)", 
            "\t# binary", 
            "\tif(numOutcomes==2 and maxValue==2 && minValue==1):", 
            "\t\tif(report>2*2^64 or report<2^64 or report==0):", 
            "\t\t\treturn(-5)", 
            "\t\t# submit report", 
            "\t\t# outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "\t\toutcome = (EVENTS.getUncaughtOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)", 
            "\t\tEVENTS.setUncaughtOutcome(eventID, outcome)", 
            "\t# categorical", 
            "\telif(numOutcomes>2):", 
            "\t\tminValue = 2^64", 
            "\t\trange = numOutcomes*2^64 - minValue", 
            "\t\tif(report<0):", 
            "\t\t\treturn(-5)", 
            "\t\tif((report*range/2^64 + minValue)>numOutcomes*2^64):", 
            "\t\t\treport = 2^64", 
            "\t\t# submit report", 
            "\t\tself.mode_items[votePeriod][eventID].report_value[report] += 1", 
            "\t\tif(self.mode_items[votePeriod][eventID].report_value[report] > self.mode_items[votePeriod][eventID].current_mode_items):", 
            "\t\t\tself.mode_items[votePeriod][eventID].current_mode = report", 
            "\t\t\tself.mode_items[votePeriod][eventID].current_mode_items = self.mode_items[votePeriod][eventID].report_value[report]", 
            "\t\toutcome = self.mode_items[votePeriod][eventID].current_mode", 
            "\t\t# outcome (uncaught and mode) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "\t\tEVENTS.setUncaughtOutcome(eventID, outcome)", 
            "\t# scalar", 
            "\telse:", 
            "\t\tif(report<0):", 
            "\t\t\treturn(-5)", 
            "\t\trange = maxValue*2^64 - minValue*2^64", 
            "\t\tif((report*range/2^64 + minValue*2^64) > maxValue*2^64):", 
            "\t\t\treport = 2^64", 
            "\t\tif((report*range/2^64 + minValue*2^64) < minValue*2^64):", 
            "\t\t\treport = 0", 
            "\t\t# submit report", 
            "\t\tself.mode_items[votePeriod][eventID].report_value[report] += 1", 
            "\t\tif(self.mode_items[votePeriod][eventID].report_value[report] > self.mode_items[votePeriod][eventID].current_mode_items):", 
            "\t\t\tself.mode_items[votePeriod][eventID].current_mode = report", 
            "\t\t\tself.mode_items[votePeriod][eventID].current_mode_items = self.mode_items[votePeriod][eventID].report_value[report]", 
            "\t\toutcome = self.mode_items[votePeriod][eventID].current_mode", 
            "\t\t# outcome (uncaught and mode) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "\t\tEVENTS.setUncaughtOutcome(eventID, outcome)", 
            "\treturn(report)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportingThreshold(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getAfterRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getBeforeRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReport(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsActual(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsExpectedEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getRRUpToDate()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReport(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportable(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportedPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getSubmittedHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "makeHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "needsReportingOn(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }
                ], 
                "name": "setAfterRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }
                ], 
                "name": "setBeforeRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventRequired(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsExpectedEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "setRRUpToDate()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportable(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReport(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }
                ], 
                "name": "validateReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]"
    }, 
    "markets": {
        "address": "0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "", 
            "# Markets' index is the marketID", 
            "# Events is a 0 indexed array of events in the market in the format of", 
            "    # [1, event, event, 2, event, 3, event, event, event]", 
            "    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events", 
            "# Sharespurchased keeps track of the number of shares purchased for each outcome", 
            "    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)", 
            "# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event", 
            "# a binary outcome state 1 is no, 2 is true, 0 if not determined", 
            "# tradingFee is a percent in fixedPoint", 
            "# tradingPeriod is which eventexpperiod market expires in", 
            "data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, forkSelection, pushingForward, bondsMan, originalPeriod, initialLiquidity[])", 
            "", 
            "def getTotalSharesPurchased(market):", 
            "    total = 0", 
            "    n = self.Markets[market].numOutcomes", 
            "    i = 0", 
            "    while i < n:", 
            "      total += self.Markets[market].sharesPurchased[i]", 
            "      i += 1", 
            "    return(total)", 
            "", 
            "def getMarketEvent(market, index):", 
            "    return(self.Markets[market].events[index])", 
            "", 
            "macro EVENTS_FIELDS: 6", 
            "macro OUTCOMES_FIELDS: 2", 
            "macro WINNING_OUTCOMES_FIELDS: 8", 
            "macro FIELDS: 12", 
            "", 
            "def getMarketInfo(marketID):", 
            "    index = FIELDS", 
            "    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "    traderFields = 1 + self.Markets[marketID].numOutcomes", 
            "    with info = array(FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):", 
            "        numEvents = self.Markets[marketID].lenEvents", 
            "        info[0] = marketID", 
            "        info[1] = self.Markets[marketID].currentParticipant", 
            "        info[2] = self.Markets[marketID].alpha", 
            "        info[3] = participantNumber", 
            "        info[4] = self.Markets[marketID].numOutcomes", 
            "        info[5] = self.Markets[marketID].tradingPeriod", 
            "        info[6] = self.Markets[marketID].tradingFee", 
            "        info[7] = self.Markets[marketID].branch", 
            "        info[8] = numEvents", 
            "        info[9] = self.Markets[marketID].cumulativeScale", 
            "        info[10] = INFO.getCreationFee(marketID)", 
            "        info[11] = INFO.getCreator(marketID)", 
            "", 
            "        # gather trader(s) info: [trader ID, 1 shares, 2 shares, 3 shares, ...]", 
            "        t = 0", 
            "        while t < self.Markets[marketID].currentParticipant:", 
            "            info[index + t*traderFields] = self.Markets[marketID].participants[t].participantID", 
            "            o = 1", 
            "            while o < self.Markets[marketID].numOutcomes + 1:", 
            "                info[index + t*traderFields + o] = self.Markets[marketID].participants[t].shares[o]", 
            "                o += 1", 
            "            t += 1", 
            "        index += self.Markets[marketID].currentParticipant*traderFields", 
            "", 
            "        # gather event(s) info:", 
            "        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]", 
            "        with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):", 
            "            i = 0", 
            "            while i < numEvents:", 
            "                with eventInfo = EVENTS.getEventInfo(events[i], outitems=EVENTS_FIELDS):", 
            "                    info[index + i*EVENTS_FIELDS] = events[i]", 
            "                    j = 1", 
            "                    while j < EVENTS_FIELDS:", 
            "                        info[index + i*EVENTS_FIELDS + j] = eventInfo[j]", 
            "                        j += 1", 
            "                i += 1", 
            "        index += numEvents*EVENTS_FIELDS", 
            "", 
            "        # gather outcomes info:", 
            "        # [sharesPurchased, price, winningOutcomes...]", 
            "        k = 0", 
            "        while k < self.Markets[marketID].numOutcomes:", 
            "            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]", 
            "            info[index + k*OUTCOMES_FIELDS + 1] = self.price(marketID, k + 1)", 
            "            k += 1", 
            "        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS", 
            "        k = 0", 
            "        while k < WINNING_OUTCOMES_FIELDS:", 
            "            info[index + k] = self.Markets[marketID].winningOutcomes[k]", 
            "            k += 1", 
            "        index += WINNING_OUTCOMES_FIELDS", 
            "", 
            "        # append description character codes", 
            "        info[index] = descriptionLength", 
            "        index += 1", 
            "        with description = INFO.getDescription(marketID, outchars=descriptionLength):", 
            "            c = 0", 
            "            while c < descriptionLength:", 
            "                info[index + c] = getch(description, c)", 
            "                c += 1", 
            "        return(info: arr)", 
            "", 
            "# Gets all information about all markets on the specified branch and", 
            "# returns it as a giant array.  getMarketsInfo requires a great deal of gas.", 
            "# Invoke using eth_call with gas=9999999999999 (or other very large number).", 
            "# @param {int} branch Branch ID that we're retrieving markets on.", 
            "# @param {int} offset Starting market index (0=full load).", 
            "# @param {int} numMarketsToLoad How many markets to load (0=all markets).", 
            "# @return array Array containing all data for all markets:", 
            "#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]", 
            "#           where length_j is the number of elements stored for market j,", 
            "#           info_j is the information array for market j, and N is the total", 
            "#           number of markets in this branch.", 
            "def getMarketsInfo(branch, offset, numMarketsToLoad):", 
            "    numMarkets = BRANCHES.getNumMarketsBranch(branch)", 
            "    with marketIDs = BRANCHES.getMarketsInBranch(branch, outitems=numMarkets):", 
            "        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:", 
            "            numMarkets = numMarketsToLoad", 
            "        with marketsMatrix = array(numMarkets):", 
            "            with marketArrayLength = array(numMarkets):", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    marketID = marketIDs[m + offset]", 
            "                    traderFields = 1 + self.Markets[marketID].numOutcomes", 
            "                    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "                    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1", 
            "                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])", 
            "                    m += 1", 
            "", 
            "                # flatten the markets info matrix so it can be returned", 
            "                # (data offset by 1+numMarkets so length data can be prepended)", 
            "                totalFlatLength = 1 + numMarkets", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    totalFlatLength += marketArrayLength[m]", 
            "                    m += 1", 
            "                with flattened = array(totalFlatLength):", 
            "                    flattened[0] = numMarkets", 
            "                    m = 0", 
            "                    while m < numMarkets:", 
            "                        flattened[m + 1] = marketArrayLength[m]", 
            "                        m += 1", 
            "                    currentFlatLength = 1 + numMarkets", 
            "                    row = 0", 
            "                    while row < numMarkets:", 
            "                        col = 0", 
            "                        while col < marketArrayLength[row]:", 
            "                            flattened[currentFlatLength + col] = marketsMatrix[row][col]", 
            "                            col += 1", 
            "                        currentFlatLength += col", 
            "                        row += 1", 
            "                    return(flattened: arr)", 
            "", 
            "def getForkSelection(market):", 
            "    return(self.Markets[market].forkSelection)", 
            "", 
            "def getMarketEvents(market):", 
            "    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)", 
            "", 
            "def getSharesPurchased(market, outcome):", 
            "    return(self.Markets[market].sharesPurchased[outcome])", 
            "", 
            "def getVolume(market):", 
            "    return(self.Markets[market].volume)", 
            "", 
            "def getParticipantNumber(market, address):", 
            "    participantNumber = self.Markets[market].addr2participant[address]", 
            "    if(self.Markets[market].participants[participantNumber].participantID != tx.origin):", 
            "        return(-1)", 
            "    else:", 
            "        return(participantNumber)", 
            "", 
            "def getParticipantID(market, participantNumber):", 
            "    return(self.Markets[market].participants[participantNumber].participantID)", 
            "", 
            "def getParticipantSharesPurchased(market, participantNumber, outcome):", 
            "    return(self.Markets[market].participants[participantNumber].shares[outcome])", 
            "", 
            "def getNumEvents(market):", 
            "    return(self.Markets[market].lenEvents)", 
            "", 
            "def getCurrentParticipantNumber(market):", 
            "    return(self.Markets[market].currentParticipant)", 
            "", 
            "def getAlpha(market):", 
            "    return(self.Markets[market].alpha)", 
            "", 
            "def getCumScale(market):", 
            "    return(self.Markets[market].cumulativeScale)", 
            "", 
            "def getMarketNumOutcomes(market):", 
            "    return(self.Markets[market].numOutcomes)", 
            "", 
            "def getTradingPeriod(market):", 
            "    return(self.Markets[market].tradingPeriod)", 
            "", 
            "def getOriginalTradingPeriod(market):", 
            "    return(self.Markets[market].originalPeriod)", 
            "", 
            "def setTradingPeriod(market, period):", 
            "    self.Markets[market].tradingPeriod = period", 
            "    return(1)", 
            "", 
            "def getTradingFee(market):", 
            "    return(self.Markets[market].tradingFee)", 
            "", 
            "def getBranchID(market):", 
            "    return(self.Markets[market].branch)", 
            "", 
            "# alpha is equal to v/(n*log(n)) where v is the max percent commission", 
            "# && n is the number of outcomes people can trade. Alpha is set when", 
            "# a market is created.", 
            "# todo: sum trick", 
            "macro lsLmsr($marketID):", 
            "    with $bq = Bq($marketID):", 
            "        with $i = 1:", 
            "            with $sumExp = 0:", 
            "                while $i <= numOutcomes($marketID):", 
            "                    $sumExp += FXP.fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)", 
            "                    $i += 1", 
            "                $bq*cumScale($marketID)*FXP.fx_log($sumExp)/2**64", 
            "", 
            "# Maximum value of array", 
            "macro maximum($a):", 
            "    with $max = $a[0]:", 
            "        with $i = 1:", 
            "            with $len = len($a):", 
            "                while $i < $len:", 
            "                    if $a[$i] > $max:", 
            "                        $max = $a[$i]", 
            "                    $i += 1", 
            "                $max", 
            "", 
            "macro sumList($q, $a, $b):", 
            "    $i = $a + 1", 
            "    $result = $q[$a]", 
            "    while $i <= $b:", 
            "        $result += $q[$i]", 
            "        $i += 1", 
            "    $result", 
            "", 
            "macro market($marketID):", 
            "    self.Markets[$marketID]", 
            "", 
            "macro alpha($marketID):", 
            "    market($marketID).alpha", 
            "", 
            "macro cumScale($marketID):", 
            "    market($marketID).cumulativeScale", 
            "", 
            "macro numOutcomes($marketID):", 
            "    market($marketID).numOutcomes", 
            "", 
            "macro sharesPurchased($marketID):", 
            "    market($marketID).sharesPurchased", 
            "", 
            "macro particpant($marketID, $addr):", 
            "    market($marketID).participants[$addr]", 
            "", 
            "macro Bq($marketID):", 
            "   alpha($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64", 
            "", 
            "def lsLmsr(marketID):", 
            "    return(lsLmsr(marketID))", 
            "", 
            "def price(market, outcome):", 
            "    a = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] += 2**50", 
            "    b = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] -= 2**50", 
            "    return(((b - a) * 2**64)/2**50)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, forkSelection):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add event list to the market", 
            "    save(self.Markets[marketID].events[0], events, items=len(events))", 
            "    self.Markets[marketID].lenEvents = len(events)", 
            "    self.Markets[marketID].tradingPeriod = tradingPeriod", 
            "    self.Markets[marketID].originalPeriod = tradingPeriod", 
            "    self.Markets[marketID].tradingFee = tradingFee", 
            "    self.Markets[marketID].branch = branch", 
            "    self.Markets[marketID].forkSelection = forkSelection", 
            "    return(1)", 
            "", 
            "def addParticipant(market, address):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    participantNumber = self.Markets[market].currentParticipant", 
            "    self.Markets[market].participants[participantNumber].participantID = address", 
            "    self.Markets[market].addr2participant[address] = participantNumber", 
            "    self.Markets[market].currentParticipant += 1", 
            "    return(participantNumber)", 
            "", 
            "def modifyShares(marketID, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    sharesPurchased(marketID)[outcome] += amount", 
            "    return(1)", 
            "", 
            "def modifyParticipantShares(branch, marketID, participantNumber, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount", 
            "    if(block.number/100>=self.getTradingPeriod(marketID)):", 
            "        return(1)", 
            "    else:", 
            "        if(amount<0):", 
            "            amount = amount*-1", 
            "        self.Markets[marketID].volume += amount", 
            "        EXPEVENTS.addPeriodVolume(branch, self.getTradingPeriod(marketID), amount)", 
            "        return(1)", 
            "", 
            "def initialLiquidityAmount(market, outcome):", 
            "    return(self.Markets[market].initialLiquidity[outcome])", 
            "", 
            "def setInitialLiquidityAmount(market, outcome, amount):", 
            "    self.Markets[market].initialLiquidity[outcome] = amount", 
            "    return(1)", 
            "", 
            "def setWinningOutcomes(market, outcomes: arr):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))", 
            "    return(1)", 
            "", 
            "def getWinningOutcomes(market):", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)", 
            "", 
            "def initialLiquiditySetup(marketID, alpha, cumScale, numOutcomes):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].alpha = alpha", 
            "    self.Markets[marketID].cumulativeScale = cumScale", 
            "    self.Markets[marketID].numOutcomes = numOutcomes", 
            "    return(1)", 
            "", 
            "def setTradingFee(market, fee):", 
            "    self.Markets[market].tradingFee = fee", 
            "    return(fee)", 
            "", 
            "def setPushedForward(market, bool):", 
            "    self.Markets[market].pushingForward = bool", 
            "    self.Markets[market].bondsMan = msg.sender", 
            "    return(1)", 
            "", 
            "def getPushedForward(market):", 
            "    return(self.Markets[market].pushingForward)", 
            "", 
            "def getBondsMan(market):", 
            "    return(self.Markets[market].bondsMan)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "addParticipant(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getAlpha(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondsMan(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCumScale(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentParticipantNumber(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkSelection(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numMarketsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInfo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantNumber(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantSharesPurchased(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedForward(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesPurchased(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalSharesPurchased(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getVolume(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "initialLiquidityAmount(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cumScale", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initialLiquiditySetup(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradingPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkSelection", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeMarket(int256,int256[],int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "lsLmsr(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyParticipantShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyShares(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "price(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialLiquidityAmount(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bool", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingFee(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingPeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomes", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWinningOutcomes(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]"
    }, 
    "orderBook": {
        "address": "0x8a4e2993a9972ee035453bb5674816fc3a698718", 
        "code": [
            "# Order logger.", 
            "event order(orderID: indexed, account: indexed, market: indexed, outcome, price, amount, expiration, cap, block)", 
            "", 
            "# sha256 hash data to create the order ID.", 
            "# @param {int} account Ethereum address of the creator", 
            "# @param {int} market Market ID (sha256 digest)", 
            "# @param {int} outcome Outcome ID", 
            "# @param {int} price Price threshold (fixed-point)", 
            "# @param {int} amount Number of shares to trade (fixed-point)", 
            "# @param {int} expiration Block number when this order expires (0 for none)", 
            "# @param {int} cap Price floor/ceiling (for limit orders; 0 for stop order)", 
            "# @return int 1 complete", 
            "def createOrder(account, market, outcome, price, amount, expiration, cap):", 
            "    with info = array(8):", 
            "        info[0] = account", 
            "        info[1] = market", 
            "        info[2] = outcome", 
            "        info[3] = price", 
            "        info[4] = amount", 
            "        info[5] = expiration", 
            "        info[6] = cap", 
            "        info[7] = block.number", 
            "        with orderID = sha256(info, items=8):", 
            "            log(type=order, orderID, account, market, outcome, price, amount, expiration, cap, info[7])", 
            "            return(orderID)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "account", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expiration", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cap", 
                        "type": "int256"
                    }
                ], 
                "name": "createOrder(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "orderID", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "account", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "expiration", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cap", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "block", 
                        "type": "int256"
                    }
                ], 
                "name": "order(int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern orderBook: [createOrder:[int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "ramble": {
        "address": "0xa34c9f6fc047cea795f69b34a063d32e6cb6288c", 
        "code": [
            "event comment(market: indexed, ipfsHash)", 
            "event metadata(market: indexed, ipfsHash)", 
            "", 
            "def addComment(market, ipfsHash):", 
            "    log(type=comment, market, ipfsHash)", 
            "    return(1)", 
            "", 
            "def addMetadata(market, ipfsHash):", 
            "    log(type=metadata, market, ipfsHash)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "addComment(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "addMetadata(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "comment(int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "metadata(int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern ramble: [addComment:[int256,int256]:int256, addMetadata:[int256,int256]:int256]"
    }, 
    "reporting": {
        "address": "0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# import makeReports as REPORTS", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "", 
            "# Reporting index is the branchID", 
            "# Reporters index is the rep. address", 
            "# We 0 index reputation so can walk thru for consensus", 
            "# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future", 
            "# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key", 
            "# Events is 0 indexed as well", 
            "data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID))", 
            "", 
            "data whitelists[](addresses[], taken)", 
            "", 
            "def init():", 
            "    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0", 
            "    self.Reporting[1010101].reputation[0].repValue = 47*2^64", 
            "    self.Reporting[1010101].reputation[0].reporterID = tx.origin", 
            "    self.Reporting[1010101].numberReporters = 2", 
            "    self.Reporting[1010101].repIDtoIndex[1010101] = 1", 
            "    self.Reporting[1010101].reputation[1].repValue = 0", 
            "    self.Reporting[1010101].reputation[1].reporterID = 1010101", 
            "    self.Reporting[1010101].totalRep += 47*2^64", 
            "", 
            "def checkWhitelist(address):", 
            "    return(self.whitelists[msg.sender].addresses[address])", 
            "", 
            "def checkContractWhitelist(contract, address):", 
            "    return(self.whitelists[contract].addresses[address])", 
            "", 
            "def setWhitelist(contract, addresses:arr):", 
            "    if self.whitelists[contract].taken:", 
            "        return(text(\"ERROR: you have to vote to change a whitelist\"):str)", 
            "    else:", 
            "        self.whitelists[contract].taken = 1", 
            "        i = 0", 
            "        l = len(addresses)", 
            "        while i <l:", 
            "            address = addresses[i]", 
            "            self.whitelists[contract].addresses[addresses] = 1", 
            "            i += 1", 
            "        return(text(\"SUCCESS\"):str)", 
            "", 
            "# @return reputation value", 
            "def getRepByIndex(branch, repIndex):", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getRepBalance(branch, address):", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "def getDormantRepByIndex(branch, repIndex):", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getDormantRepBalance(branch, address):", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "def getReporterID(branch, index):", 
            "    return(self.Reporting[branch].reputation[index].reporterID)", 
            "", 
            "def getTotalRep(branch):", 
            "    return(self.Reporting[branch].totalRep)", 
            "", 
            "# will return 0s for array values after it's looped through all the ones you", 
            "# have an actual balance in", 
            "def getReputation(address):", 
            "    branchListCount = BRANCHES.getNumBranches()", 
            "    if(address):", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    else:", 
            "        address = tx.origin", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumberReporters(branch):", 
            "    return(self.Reporting[branch].numberReporters)", 
            "", 
            "def repIDToIndex(branch, repID):", 
            "    return(self.Reporting[branch].repIDtoIndex[repID])", 
            "", 
            "def hashReport(report: arr, salt):", 
            "    hashInfo = array(len(report) + 2)", 
            "    hashInfo[0] = tx.origin", 
            "    hashInfo[1] = salt", 
            "    i = 2", 
            "    while i < (len(report) + 2):", 
            "        hashInfo[i] = report[i-2]", 
            "        i += 1", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setInitialReporters(parent, branchID):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add branch as a \"reporter\"", 
            "    self.Reporting[branchID].numberReporters = 1", 
            "    self.Reporting[branchID].repIDtoIndex[branchID] = 0", 
            "    self.Reporting[branchID].reputation[0].repValue = 0", 
            "    self.Reporting[branchID].reputation[0].reporterID = branchID", 
            "    return(1)", 
            "", 
            "#def claimInitialRep(parent, branchID):", 
            "    # have 1 month to claim", 
            "#    if(self.repIDToIndex(branchID, msg.sender)==0 && block.number < (BRANCHES.getCreationDate(branchID) + 216000)):", 
            "#        i = self.Reporting[branchID].numberReporters", 
            " #       rep = REPORTS.getBeforeRep(parent, BRANCHES.getParentPeriod(branchID))", 
            "  #      reporterID = msg.sender", 
            "   #     self.Reporting[branchID].reputation[i].reporterID = reporterID", 
            "    #    self.Reporting[branchID].reputation[i].repValue = rep", 
            "     #   self.Reporting[branchID].repIDtoIndex[reporterID] = i", 
            "      #  self.Reporting[branchID].dormantRep[i].reporterID = reporterID", 
            "       # self.Reporting[branchID].dormantRep[i].repValue = REPORTS.getDormantRep(parent, BRANCHES.getParentPeriod(branchID))", 
            "        #self.Reporting[branchID].numberReporters += 1", 
            "        #self.Reporting[branchID].totalRep += rep", 
            "        #return(1)", 
            "    #else:", 
            "        # already claimed or too late", 
            "     #   return(0)", 
            "", 
            "def addReporter(branch, sender):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    reporterIndex = self.Reporting[branch].numberReporters", 
            "    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex", 
            "    self.Reporting[branch].reputation[reporterIndex].repValue = 0", 
            "    self.Reporting[branch].reputation[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].numberReporters += 1", 
            "    return(1)", 
            "", 
            "def addRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue -= value", 
            "    return(1)", 
            "", 
            "def setRep(branch, index, newRep):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    oldRep = self.Reporting[branch].reputation[index].repValue", 
            "    self.Reporting[branch].reputation[index].repValue = newRep", 
            "    self.Reporting[branch].totalRep += newRep - oldRep", 
            "    return(1)", 
            "", 
            "def addDormantRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractDormantRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue -= value", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setSaleDistribution(addresses: arr, balances: arr, branchID):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    i = 0", 
            "    while i < len(addresses):", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]", 
            "        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters", 
            "        self.Reporting[branchID].numberReporters += 1", 
            "        i+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "addReporter(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkContractWhitelist(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkWhitelist(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getReputation(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }
                ], 
                "name": "hashReport(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repID", 
                        "type": "int256"
                    }
                ], 
                "name": "repIDToIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newRep", 
                        "type": "int256"
                    }
                ], 
                "name": "setRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "balances", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setSaleDistribution(int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWhitelist(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]"
    }, 
    "sendReputation": {
        "address": "0x5f67ab9ff79be97b27ac8f26ef9f4b429b82e2df", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "REPORTS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern consensus: [collectFees:[int256]:int256, incrementPeriodAfterReporting:[int256]:int256, penalizationCatchup:[int256]:int256, penalizeNotEnoughReports:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256,int256,int256]:int256, slashRep:[int256,int256,int256,int256,int256]:int256]", 
            "CONSENSUS = 0x6c4c9fa11d6d8ed2c7a08ddcf4d4654c85194f68", 
            "", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "def sendReputation(branch, recver, value):", 
            "    # Rep cannot be simultaneously spent (transferred) and used to vote", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    #if(value<=0 || !CASH.send(branch, 5*2^64) || EXPEVENTS.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, recver, 0) != 0):", 
            "    # MAKEREPORTS.getReportedPeriod(branch, current)", 
            "    #    return(0)", 
            "    # need to check all this for the person it's being sent to as well", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "    #    self.RRDone = true", 
            "    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):", 
            "    #    CONSENSUS.collectFees(lastPeriod)", 
            "    # before rep, after rep, balance", 
            "    # person you're sending to needs rr up to date / done as well", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addRep(branch, receiverIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "def sendDormantRep(branch, recver, value):", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0 || !CASH.send(branch, 5*2^64)):", 
            "        return(0)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.getDormantRepBalance(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, receiverIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "def convertToDormantRep(branch, value):", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "\t\t# benny comment:", 
            "            #```Maybe still have this sort-of variable \"power\" to it, but REP initially doesn't have \"full-power\", or REP that hasn't been used to report over the past week has now let it's \"power-meter\" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch \"on\" or switch \"off\" the REP. If a user knows, \"I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power\", well that's pretty good incentive to keep the user active, without actually taking it from them.```", 
            "", 
            "    if(value<=0 || !CASH.send(branch, 5*2^64) || REPORTS.getSubmittedHash(branch, period, msg.sender)):", 
            "        return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, senderIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "def convertToActiveRep(branch, value):", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "", 
            "    if(value<=0 || !CASH.send(branch, 5*2^64) || REPORTS.getSubmittedHash(branch, period, msg.sender)):", 
            "        return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()):", 
            "        #doIt()", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.getDormantRepBalance(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addRep(branch, senderIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToActiveRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToDormantRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "sendDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "sendReputation(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern sendReputation: [convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendDormantRep:[int256,int256,int256]:int256, sendReputation:[int256,int256,int256]:int256]"
    }, 
    "transferShares": {
        "address": "0xe5b327630cfa7f4b2324f9066c897dceecfd88a3", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "", 
            "# @return amount of shares transferred", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or you haven't traded in this market (or market doesn't exist)", 
            "    # -2: user actually doesn't have the shares", 
            "    # -3: not enough money to transfer the shares", 
            "def transferShares(branch, market, outcome, amount, to):", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    receiverNumber = MARKETS.getParticipantNumber(market, to)", 
            "    # make sure outcome exists", 
            "    if (outcome==0 || MARKETS.getParticipantID(market, participantNumber) != tx.origin):", 
            "        return(-1)", 
            "    if(to != MARKETS.getParticipantID(market, receiverNumber)):", 
            "        receiverNumber = MARKETS.addParticipant(market, to)", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, return -2", 
            "    if(MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):", 
            "        return(-2)", 
            "    MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)", 
            "    MARKETS.modifyParticipantShares(branch, market, receiverNumber, outcome, amount)", 
            "", 
            "    # half of fees to market creator", 
            "    # other half go to branch", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, 2^32)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    price = 2^32*(newCost - oldCost)", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    MARKETS.modifyShares(market, outcome, -2^32)", 
            "    if((CASH.balance(tx.origin) >= fee) && CASH.send(INFO.getCreator(market), fee/2) && CASH.send(branch, fee/2)):", 
            "        return(amount)", 
            "    else:", 
            "        return(-3)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "to", 
                        "type": "int256"
                    }
                ], 
                "name": "transferShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern transferShares: [transferShares:[int256,int256,int256,int256,int256]:int256]"
    }
}